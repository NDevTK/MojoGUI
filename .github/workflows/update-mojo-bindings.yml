name: Update Mojo JS Bindings

on:
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday at midnight UTC
  workflow_dispatch:  # Manual trigger
  push:
    branches: [main]
    paths:
      - '.github/workflows/update-mojo-bindings.yml'

permissions:
  contents: write

jobs:
  update-bindings:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Create working directories
        run: |
          mkdir -p chromium_src
          mkdir -p bindings

      - name: Sparse checkout .mojom files from Chromium
        run: |
          cd chromium_src
          git init
          git remote add origin https://chromium.googlesource.com/chromium/src.git
          git config core.sparseCheckout true
          
          # Use universal pattern to get ALL .mojom files regardless of location
          # Also get mojo/public for base types and dependencies
          cat > .git/info/sparse-checkout << 'EOF'
          mojo/public/
          **/*.mojom
          EOF
          
          git pull --depth=1 origin main || git pull --depth=1 origin master

      - name: List .mojom files
        run: |
          # Finds all .mojom files in chromium_src
          # We sort them to help with stability, though dependencies matter more
          find chromium_src -name "*.mojom" | sort > mojom_files.txt
          
          echo "Found $(wc -l < mojom_files.txt) .mojom files"
          head -10 mojom_files.txt

      - name: Generate Mojo JS bindings
        run: |
          echo "Generating Mojo JS bindings..."
          
          # Set up paths
          export PYTHONPATH="$PYTHONPATH:$(pwd)/chromium_src"
          
          # Directory for bindings
          mkdir -p bindings
          
          # Create a Python script to drive the generation
          cat << 'SCRIPT' > generate_bindings.py
          import os
          import json
          import re
          import datetime
          from pathlib import Path

          # Configuration
          ROOT_DIR = 'chromium_src'

          TYPE_MAPPING = {
              'bool': 'mojo.internal.Bool',
              'int8': 'mojo.internal.Int8',
              'int16': 'mojo.internal.Int16',
              'int32': 'mojo.internal.Int32',
              'int64': 'mojo.internal.Int64',
              'uint8': 'mojo.internal.Uint8',
              'uint16': 'mojo.internal.Uint16',
              'uint32': 'mojo.internal.Uint32',
              'uint64': 'mojo.internal.Uint64',
              'float': 'mojo.internal.Float',
              'double': 'mojo.internal.Double',
              'string': 'mojo.internal.String',
              'handle': 'mojo.internal.Handle',
          }

          def parse_mojom_file(file_path):
              """Parse a .mojom file and extract interface definitions using regex."""
              try:
                  with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                      content = f.read()
              except Exception as e:
                  return None


              result = {
                  'path': str(file_path),
                  'module': None,
                  'imports': [],
                  'interfaces': [],
                  'structs': [],
                  'enums': []
              }

              # Extract module name
              module_match = re.search(r'module\s+([\w.]+)\s*;', content)
              if module_match:
                  result['module'] = module_match.group(1)

              # Extract imports
              imports = re.findall(r'import\s+"([^"]+)"', content)
              result['imports'] = imports

              # Remove comments for cleaner parsing
              content_no_comments = re.sub(r'//[^\n]*', '', content)
              content_no_comments = re.sub(r'/\*.*?\*/', '', content_no_comments, flags=re.DOTALL)

              # Extract interfaces with their methods
              interface_pattern = r'interface\s+(\w+)\s*\{'
              for match in re.finditer(interface_pattern, content_no_comments):
                  interface_name = match.group(1)
                  start_pos = match.end()
                  
                  # Find matching closing brace
                  brace_count = 1
                  end_pos = start_pos
                  while brace_count > 0 and end_pos < len(content_no_comments):
                      if content_no_comments[end_pos] == '{':
                          brace_count += 1
                      elif content_no_comments[end_pos] == '}':
                          brace_count -= 1
                      end_pos += 1
                  
                  interface_body = content_no_comments[start_pos:end_pos-1]
                  
                  methods = []
                  method_pattern = r'([A-Z][a-zA-Z0-9_]*)\s*\(([^)]*)\)\s*(?:=>\s*\(([^)]*)\))?'
                  for method_match in re.finditer(method_pattern, interface_body):
                      method_name = method_match.group(1)
                      params_str = method_match.group(2).strip()
                      returns_str = method_match.group(3)
                      
                      # Skip false positives
                      if method_name in ('TODO', 'NOTE', 'FIXME', 'DEPRECATED', 'If', 'For', 'While', 'Switch'):
                          continue
                      
                      params = parse_params(params_str) if params_str else []
                      returns = parse_params(returns_str) if returns_str else []
                      
                      methods.append({
                          'name': method_name,
                          'params': params,
                          'returns': returns
                      })
                  
                  # Deduplicate methods
                  seen = set()
                  unique_methods = []
                  for m in methods:
                      if m['name'] not in seen:
                          seen.add(m['name'])
                          unique_methods.append(m)
                  
                  result['interfaces'].append({
                      'name': interface_name,
                      'methods': unique_methods
                  })

              # Extract enums
              enum_pattern = r'enum\s+(\w+)\s*\{([^}]*)\}'
              for match in re.finditer(enum_pattern, content_no_comments, re.DOTALL):
                  enum_name = match.group(1)
                  enum_body = match.group(2)
                  values = []
                  for line in enum_body.split(','):
                      line = line.strip()
                      if line:
                          value_match = re.match(r'([a-zA-Z_][a-zA-Z0-9_]*)', line)
                          if value_match:
                              values.append(value_match.group(1))
                  result['enums'].append({'name': enum_name, 'values': values})

              # Extract structs
              struct_pattern = r'struct\s+(\w+)\s*\{([^}]*)\}'
              for match in re.finditer(struct_pattern, content_no_comments, re.DOTALL):
                  struct_name = match.group(1)
                  struct_body = match.group(2)
                  fields = parse_params(struct_body)
                  result['structs'].append({'name': struct_name, 'fields': fields})

              return result

          def parse_params(params_str):
              """Parse parameter string into list of param objects."""
              if not params_str:
                  return []
              
              params = []
              depth = 0
              current = ""
              for char in params_str:
                  if char in '<([':
                      depth += 1
                  elif char in '>)]':
                      depth -= 1
                  elif (char == ',' or char == ';') and depth == 0:
                      if current.strip():
                          p = parse_single_param(current.strip())
                          if p:
                              params.append(p)
                      current = ""
                      continue
                  current += char
              
              if current.strip():
                  p = parse_single_param(current.strip())
                  if p:
                      params.append(p)
              
              return params

          def parse_single_param(param_str):
              """Parse a single parameter like 'string name'."""
              param_str = param_str.strip()
              if not param_str:
                  return None
              
              param_str = re.sub(r'//.*$', '', param_str, flags=re.MULTILINE).strip()
              param_str = re.sub(r'=.*$', '', param_str).strip()
              param_str = param_str.rstrip(';').strip()
              
              if not param_str:
                  return None
              
              optional = '?' in param_str
              param_str = param_str.replace('?', '').strip()
              
              parts = param_str.split()
              if len(parts) >= 2:
                  param_type = ' '.join(parts[:-1])
                  param_name = parts[-1]
              elif len(parts) == 1:
                  param_type = parts[0]
                  param_name = ""
              else:
                  return None
              
              if param_name and not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', param_name):
                  return None
              
              return {'type': param_type, 'name': param_name, 'optional': optional}

          def to_camel_case(name):
              """Convert PascalCase to camelCase."""
              if name and name[0].isupper():
                  return name[0].lower() + name[1:]
              components = name.split('_')
              return components[0] + ''.join(x.title() for x in components[1:])

          def mojo_type_map(mojom_type):
              """Map mojom types to mojo.internal types."""
              type_clean = mojom_type.replace('?', '').strip()
              
              # Check for arrays
              if type_clean.startswith('array<'):
                  return 'mojo.internal.Array'
              
              # Check for maps
              if type_clean.startswith('map<'):
                  return 'mojo.internal.Map'
              
              # Check for pending_receiver/pending_remote
              if type_clean.startswith('pending_receiver<'):
                  return 'mojo.internal.InterfaceRequest'
              if type_clean.startswith('pending_remote<'):
                  return 'mojo.internal.InterfaceProxy'
              if type_clean.startswith('pending_associated_receiver<'):
                  return 'mojo.internal.AssociatedInterfaceRequest'
              if type_clean.startswith('pending_associated_remote<'):
                  return 'mojo.internal.AssociatedInterfaceProxy'
              
              # Look up in type map
              if type_clean in TYPE_MAPPING:
                  return TYPE_MAPPING[type_clean]
              
              # For unknown types (likely structs/enums), default to pointer
              return 'mojo.internal.Pointer'


          def generate_js_binding(parsed):
              """Generate JavaScript binding code that works with the Mojo runtime."""
              if not parsed or not parsed.get('module'):
                  return None
              
              module = parsed['module']
              module_parts = module.split('.')
              
              # Build set of valid types for this module
              valid_types = set()
              for s in parsed.get('structs', []): valid_types.add(s['name'])
              for e in parsed.get('enums', []): valid_types.add(e['name'])
              
              # Map imports to their module namespaces (naive mapping)
              # Standard Mojo mapping: "foo/bar/baz.mojom" -> "baz.mojom" -> "baz.mojom.Type"
              # We need to be smarter. For now, assume if it looks like a Type, it might be one.
              
              def resolve_mojo_type(type_name):
                  # Check basic types first
                  if type_name in TYPE_MAPPING or type_name.startswith('array') or type_name.startswith('map') or type_name.startswith('pending'):
                       return mojo_type_map(type_name)

                  # Check local types
                  clean_name = type_name.replace('?', '').strip()
                  if clean_name in valid_types:
                      return f"{module}.{clean_name}Spec"
                  
                  # Check imports (if it contains dot that is not part of module path)
                  # If looks like "some.module.Type", assume it matches "some.module.TypeSpec"
                  if '.' in clean_name:
                      return f"{clean_name}Spec"
                  
                  # Fallback to Pointer if unknown (could be interface pointer or other)
                  # Better: if it starts with valid char and not lowercase primitive, assume it is a struct/enum reference in same package if not qualified?
                  # But Mojo types in methods often are just "BatteryStatus".
                  # If we found it in 'valid_types', we returned Spec.
                  # If not, maybe it's from another module but passed without qualification? (Unlikely in Mojo, usually imported)
                  
                  # Fallback
                  return 'mojo.internal.Pointer'

              def get_struct_layout(params):
                  """Calculate field offsets and size with boolean bit packing."""
                  fields_code = []
                  offset = 0
                  bit = 0
                  
                  # Filter valid params and assign weight
                  valid_params = [p for p in params if p and p.get('name')]
                  
                  def get_size_weight(param):
                      p_type = resolve_mojo_type(param.get('type', 'string'))
                      if p_type == 'mojo.internal.Bool': return 0
                      # Need to handle actual type refs which are Pointers (weight 8) or Enums (Int32, weight 4)
                      # If it's a Spec reference (contains dot or Spec), it's a pointer to struct -> 8 bytes?
                      # Or if it ends in Spec?
                      # Structs are passed by pointer in MojoJS -> 8 bytes.
                      # Enums are Int32 -> 4 bytes.
                      # We need to distinguish Enums from Structs in resolve_mojo_type or here.
                      # For now, if it resolves to a Spec string, assume Struct (8 bytes).
                      if 'Spec' in p_type and 'Enum' not in p_type: return 8
                      if p_type in ('mojo.internal.Int8', 'mojo.internal.Uint8'): return 1
                      if p_type in ('mojo.internal.Int16', 'mojo.internal.Uint16'): return 2
                      if p_type in ('mojo.internal.Int32', 'mojo.internal.Uint32', 'mojo.internal.Float', 'mojo.internal.InterfaceRequest', 'mojo.internal.InterfaceProxy', 'mojo.internal.AssociatedInterfaceRequest', 'mojo.internal.AssociatedInterfaceProxy', 'mojo.internal.Handle'): return 4
                      return 8 # Default 8

                  # Sort: primary by size (desc), secondary by original index (stable)
                  # Python sort is stable, so just sort by weight desc
                  valid_params.sort(key=get_size_weight, reverse=True)
                  
                  for param in valid_params:
                      p_type = resolve_mojo_type(param.get('type', 'string'))
                      is_bool = p_type == 'mojo.internal.Bool'
                      nullable = 'true' if param.get('optional') or '?' in param.get('type', '') else 'false'
                      
                      if is_bool:
                          f_off = offset
                          f_bit = bit
                          bit += 1
                      else:
                          # If we were packing bits, move to next 8-byte word
                          if bit > 0:
                              bit = 0
                              offset += 8
                          
                          # Alignment
                          weight = get_size_weight(param)
                          if weight == 0: weight = 1
                          
                          if offset % weight != 0:
                              offset += (weight - (offset % weight))
                          
                          f_off = offset
                          f_bit = 0
                          offset += weight
                      
                      fields_code.append(f"{{ name: '{param['name']}', packedOffset: {f_off}, packedBitOffset: {f_bit}, type: {p_type}, nullable: {nullable} }}")
                  
                  if bit > 0:
                      offset += 8
                  
                  # Align struct size to 8 bytes
                  if offset % 8 != 0:
                      offset += (8 - (offset % 8))
                  
                  packed_size = 8 + offset  # Header (8 bytes) + payload
                  return fields_code, packed_size

              
              # Build namespace chain
              js_code = f'''// Auto-generated MojoJS binding
          // Source: {parsed['path']}
          // Module: {module}

          'use strict';

          // Module namespace
          var {module_parts[0]} = {module_parts[0]} || {{}};
          '''
              
              current_ns = module_parts[0]
              for part in module_parts[1:]:
                  js_code += f"{current_ns}.{part} = {current_ns}.{part} || {{}};\n"
                  current_ns += f".{part}"
              
              js_code += "\n"
              
              # Generate enums
              # Generate enums
              for enum in parsed.get('enums', []):
                  js_code += f"\n// Enum: {enum['name']}\n"
                  js_code += f"{current_ns}.{enum['name']} = {{\n"
                  for i, value in enumerate(enum['values']):
                      js_code += f"  {value}: {i},\n"
                  js_code += "};\n"

              # Generate structs
              for struct in parsed.get('structs', []):
                  struct_name = struct['name']
                  full_name = f"{current_ns}.{struct_name}"
                  fields_code, packed_size = get_struct_layout(struct.get('fields', []))
                  
                  js_code += f"\n// Struct: {struct_name}\n"
                  js_code += f"{full_name}Spec = {{\n"
                  js_code += "  $: {\n"
                  js_code += "    structSpec: {\n"
                  js_code += f"      name: '{module}.{struct_name}',\n"
                  js_code += f"      packedSize: {packed_size},\n"
                  js_code += "      fields: [\n"
                  for field in fields_code:
                      js_code += f"        {field},\n"
                  js_code += "      ],\n"
                  js_code += "      versions: [{version: 0}]\n"
                  js_code += "    }\n"
                  js_code += "  }\n"
                  js_code += "};\n"
              
              # Generate interface classes with proper getRemote() method
              for interface in parsed.get('interfaces', []):
                  iface_name = interface['name']
                  full_name = f"{current_ns}.{iface_name}"
                  interface_string = f"{module}.{iface_name}"
                  
                  # Create the interface namespace object
                  js_code += f"\n// Interface: {iface_name}\n"
                  js_code += f"{full_name} = {{}};\n\n"
                  
                  # Generate PendingReceiver class first (needed by Remote)
                  js_code += f"{full_name}PendingReceiver = class {{\n"
                  js_code += "  constructor(handle) {\n"
                  js_code += "    this.handle = handle;\n"
                  js_code += "  }\n"
                  js_code += "};\n\n"
                  
                  # Generate Remote class with getRemote() static method
                  js_code += f"{full_name}Remote = class {{\n"
                  js_code += f"  static get $interfaceName() {{\n"
                  js_code += f"    return '{interface_string}';\n"
                  js_code += "  }\n\n"
                  
                  js_code += "  constructor(handle = undefined) {\n"
                  js_code += f"    this.proxy = new mojo.internal.interfaceSupport.InterfaceRemoteBase(\n"
                  js_code += f"      {full_name}PendingReceiver,\n"
                  js_code += "      handle);\n"
                  js_code += f"    this.$ = new {full_name}RemoteCallHandler(this.proxy);\n"
                  js_code += "  }\n\n"
                  
                  js_code += "  bindNewPipeAndPassReceiver() {\n"
                  js_code += "    return this.proxy.bindNewPipeAndPassReceiver();\n"
                  js_code += "  }\n\n"
                  
                  js_code += "  close() {\n"
                  js_code += "    this.proxy.close();\n"
                  js_code += "  }\n"
                  js_code += "};\n\n"
                  
                  # Generate RemoteCallHandler with methods
                  js_code += f"{full_name}RemoteCallHandler = class {{\n"
                  js_code += "  constructor(proxy) {\n"
                  js_code += "    this.proxy = proxy;\n"
                  js_code += "  }\n\n"
                  
                  for idx, method in enumerate(interface.get('methods', [])):
                      params_list = [p['name'] for p in method.get('params', []) if p and p.get('name')]
                      params_str = ', '.join(params_list)
                      method_name_camel = to_camel_case(method['name'])
                      
                      js_code += f"  {method_name_camel}({params_str}) {{\n"
                      js_code += f"    // Ordinal: {idx}\n"
                      js_code += "    return this.proxy.sendMessage(\n"
                      js_code += f"      {idx},  // ordinal\n"
                      js_code += f"      {full_name}_{method['name']}_ParamsSpec,\n"
                      if method.get('returns'):
                          js_code += f"      {full_name}_{method['name']}_ResponseParamsSpec,\n"
                      else:
                          js_code += "      null,\n"
                      js_code += f"      [{params_str}]);\n"
                      js_code += "  }\n\n"
                  
                  js_code += "};\n\n"
                  
                  # Generate static getRemote() factory function
                  js_code += f"{full_name}.getRemote = function() {{\n"
                  js_code += f"  let remote = new {full_name}Remote();\n"
                  js_code += "  let receiver = remote.bindNewPipeAndPassReceiver();\n"
                  js_code += f"  mojo.internal.interfaceSupport.bind(\n"
                  js_code += f"    receiver.handle,\n"
                  js_code += f"    '{interface_string}',\n"
                  js_code += "    'context');\n"
                  js_code += "  return remote.$;\n"
                  js_code += "};\n\n"
                  
                  # Generate ParamsSpec placeholders for each method
                  for idx, method in enumerate(interface.get('methods', [])):
                      # Calculate layout for Params
                      params_code, params_size = get_struct_layout(method.get('params', []))
                      
                      js_code += f"// ParamsSpec for {method['name']}\n"
                      js_code += f"{full_name}_{method['name']}_ParamsSpec = {{\n"
                      js_code += "  $: {\n"
                      js_code += "    structSpec: {\n"
                      js_code += f"      name: '{interface_string}.{method['name']}_Params',\n"
                      js_code += f"      packedSize: {params_size},\n"
                      js_code += "      fields: [\n"
                      for field in params_code:
                          js_code += f"        {field},\n"
                      js_code += "      ],\n"
                      js_code += "      versions: [{version: 0}]\n"
                      js_code += "    }\n"
                      js_code += "  }\n"
                      js_code += "};\n\n"
                      
                      if method.get('returns'):
                          # Calculate layout for ResponseParams
                          ret_code, ret_size = get_struct_layout(method.get('returns', []))
                          
                          js_code += f"{full_name}_{method['name']}_ResponseParamsSpec = {{\n"
                          js_code += "  $: {\n"
                          js_code += "    structSpec: {\n"
                          js_code += f"      name: '{interface_string}.{method['name']}_ResponseParams',\n"
                          js_code += f"      packedSize: {ret_size},\n"
                          js_code += "      fields: [\n"
                          for field in ret_code:
                              js_code += f"        {field},\n"
                          js_code += "      ],\n"
                          js_code += "      versions: [{version: 0}]\n"
                          js_code += "    }\n"
                          js_code += "  }\n"
                          js_code += "};\n\n"
                  
                  # Also add legacy-style Ptr class for compatibility
                  js_code += f"// Legacy compatibility\n"
                  js_code += f"{full_name}Ptr = {full_name}Remote;\n"
                  js_code += f"{full_name}Request = {full_name}PendingReceiver;\n\n"
              
              return js_code



          def main():
              bindings_dir = Path('bindings')
              
              with open('mojom_files.txt', 'r') as f:
                  files = [line.strip() for line in f if line.strip()]
              
              print(f"Processing {len(files)} files...")
              
              success_count = 0
              
              index_data = {
                  'generated_at': datetime.datetime.utcnow().isoformat() + 'Z',
                  'interfaces': [],
                  'files': []
              }
              
              for mojom_path in files:
                  if not os.path.isfile(mojom_path):
                      continue
                  
                  # Parse and generate bindings
                  parsed = parse_mojom_file(mojom_path)
                  if parsed and (parsed.get('interfaces') or parsed.get('structs') or parsed.get('enums')):
                      rel_path = mojom_path.replace('chromium_src/', '')
                      out_filename = rel_path.replace('/', '_').replace('.mojom', '.mojom.js')
                      out_path = bindings_dir / out_filename
                      
                      js_code = generate_js_binding(parsed)
                      if js_code:
                          with open(out_path, 'w') as f:
                              f.write(js_code)
                          success_count += 1
                          
                          for interface in parsed['interfaces']:
                              index_data['interfaces'].append({
                                  'name': interface['name'],
                                  'module': parsed['module'],
                                  'file': out_filename,
                                  'methods': [m['name'] for m in interface.get('methods', [])]
                              })
                          
                          index_data['files'].append({
                              'filename': out_filename,
                              'source': rel_path,
                              'module': parsed['module'],
                              'imports': parsed.get('imports', [])
                          })
              
              # Write index.json
              with open(bindings_dir / 'index.json', 'w') as f:
                  json.dump(index_data, f, indent=2)
              
              # Print summary
              print(f"\n=== Results ===")
              print(f"Generated bindings: {success_count} files")
              print(f"Total interfaces: {len(index_data['interfaces'])}")

          if __name__ == '__main__':
              main()
          SCRIPT
          
          # Run the script
          python generate_bindings.py
          


      - name: Generate index.js
        run: |
          cat > bindings/index.js << 'EOF'
          // MojoJS Bindings Index
          // Auto-generated - Do not edit manually

          (function(global) {
            'use strict';

            // Create trusted types policy for script URLs
            let trustedPolicy = null;
            if (typeof window.trustedTypes !== 'undefined') {
              try {
                trustedPolicy = window.trustedTypes.createPolicy('mojoBindings', {
                  createScriptURL: (input) => input
                });
              } catch (e) {
                console.warn('Could not create trusted types policy:', e);
              }
            }

            const MojoBindings = {
              _indexData: null,
              _loadedModules: {},

              async loadIndex() {
                if (this._indexData) return this._indexData;
                const response = await fetch('./bindings/index.json');
                this._indexData = await response.json();
                return this._indexData;
              },

              async getInterfaces() {
                const data = await this.loadIndex();
                return data.interfaces;
              },

              async searchInterfaces(query) {
                const interfaces = await this.getInterfaces();
                const q = query.toLowerCase();
                return interfaces.filter(i => 
                  i.name.toLowerCase().includes(q) || 
                  i.module.toLowerCase().includes(q)
                );
              },

              async loadBinding(filename) {
                if (this._loadedModules[filename]) {
                  return this._loadedModules[filename];
                }
                
                // Load index to resolve dependencies
                const data = await this.loadIndex();
                const fileEntry = data.files.find(f => f.filename === filename);
                
                if (fileEntry && fileEntry.imports && fileEntry.imports.length > 0) {
                  const loadPromises = fileEntry.imports.map(async (importPath) => {
                     // Find the file entry that matches this import source
                     const importEntry = data.files.find(f => f.source === importPath);
                     if (importEntry) {
                       await this.loadBinding(importEntry.filename);
                     }
                  });
                  await Promise.all(loadPromises);
                }

                return new Promise((resolve, reject) => {
                  this._loadedModules[filename] = true;

                  const script = document.createElement('script');
                  const scriptUrl = `./bindings/${filename}`;
                  
                  if (trustedPolicy) {
                    script.src = trustedPolicy.createScriptURL(scriptUrl);
                  } else {
                    script.src = scriptUrl;
                  }
                  
                  script.onload = () => {
                    resolve(true);
                  };
                  script.onerror = () => {
                    reject(new Error(`Failed to load binding: ${filename}`));
                  };
                  document.head.appendChild(script);
                });
              },

              getMetadata() {
                return this._indexData;
              }
            };

            global.MojoBindings = MojoBindings;
          })(typeof window !== 'undefined' ? window : this);
          EOF



      - name: Cleanup temporary files
        run: |
          # Remove all temporary files that should NOT be committed
          rm -rf chromium_src/
          rm -f mojom_files.txt
          echo "Cleaned up temporary files"

      - name: Commit only generated binding files
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Only add generated binding files - NOT core runtime files
          # Core files (bindings_lite.js, interface_support.js, etc.) should not be modified
          git add bindings/*.mojom.js
          git add bindings/index.js
          git add bindings/index.json
          
          # Show what will be committed
          echo "Files staged for commit:"
          git diff --staged --name-only
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            CHANGED_COUNT=$(git diff --staged --name-only | wc -l)
            git commit -m "Update Mojo JS bindings - $(date -u +%Y-%m-%d) [$CHANGED_COUNT files]"
            git push
          fi
