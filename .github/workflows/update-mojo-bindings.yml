name: Update Mojo JS Bindings

on:
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday at midnight UTC
  workflow_dispatch:  # Manual trigger
  push:
    branches: [main]
    paths:
      - '.github/workflows/update-mojo-bindings.yml'

permissions:
  contents: write

jobs:
  update-bindings:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install jinja2 ply

      - name: Create working directories
        run: |
          mkdir -p chromium_src
          mkdir -p bindings

      - name: Sparse checkout .mojom files from Chromium
        run: |
          cd chromium_src
          git init
          git remote add origin https://chromium.googlesource.com/chromium/src.git
          git config core.sparseCheckout true
          
          # Use universal pattern to get ALL .mojom files regardless of location
          # Also get mojo/public for base types and dependencies
          cat > .git/info/sparse-checkout << 'EOF'
          mojo/public/
          **/*.mojom
          EOF
          
          git pull --depth=1 origin main || git pull --depth=1 origin master

      - name: Filter broken .mojom files
        run: |
          # Find ALL .mojom files first
          find chromium_src -name "*.mojom" > all_mojoms.txt
          
          # Create skip list for problematic files that crash the tool
          cat << 'EOF' > skip_list.txt
          gpu/ipc/common/exported_shared_image.mojom
          EOF
          
          # Create the filter script
          cat << 'EOF' > filter_mojoms.py
          import os
          import sys
          import re
          
          # Configuration
          ROOTS = [os.getcwd(), os.path.join(os.getcwd(), 'chromium_src')]
          
          def resolve_import(import_path, current_file_path):
              # Imports are relative to roots.
              # But sometimes they might be relative to the file?
              # Mojo docs say imports are relative to source root.
              for root in ROOTS:
                  candidate = os.path.join(root, import_path)
                  if os.path.isfile(candidate):
                      return candidate
              return None

          def parse_imports(file_path):
              imports = []
              try:
                  with open(file_path, 'r', encoding='utf-8') as f:
                      content = f.read()
                  # Regex for: import "foo/bar.mojom";
                  # Simplistic, ignores comments, but sufficient for 99%
                  matches = re.findall(r'^\s*import\s+"([^"]+)"', content, re.MULTILINE)
                  return matches
              except Exception as e:
                  print(f"Error reading {file_path}: {e}")
                  return None

          def main():
              with open('all_mojoms.txt', 'r') as f:
                  files = [line.strip() for line in f if line.strip()]
              
              skip_patterns = []
              if os.path.exists('skip_list.txt'):
                  with open('skip_list.txt', 'r') as f:
                      skip_patterns = [line.strip() for line in f if line.strip()]
              
              # Map absolute path -> list of absolute paths it imports
              dependency_graph = {}
              # Map clean relative path (for output) -> absolute path
              
              abs_files = set()
              for f in files:
                  # Check skip list
                  should_skip = False
                  for pattern in skip_patterns:
                      if pattern in f:
                          print(f"Skipping {f} (matched skip pattern '{pattern}')")
                          should_skip = True
                          break
                  if should_skip:
                      continue

                  abs_path = os.path.abspath(f)
                  abs_files.add(abs_path)
              
              print(f"Scanning {len(abs_files)} files for broken dependencies...")
              
              for f in files:
                  abs_path = os.path.abspath(f)
                  if abs_path not in abs_files:
                      continue

                  imports = parse_imports(abs_path)
                  if imports is None:
                      continue # File unreadable
                  
                  dependency_graph[abs_path] = []
                  for imp in imports:
                      resolved = resolve_import(imp, abs_path)
                      if not resolved:
                          # Dependency missing!
                          # print(f"File {f} is missing dependency {imp}")
                          # Add a dummy marker that won't be in abs_files
                          dependency_graph[abs_path].append(f"MISSING:{imp}")
                      else:
                          dependency_graph[abs_path].append(resolved)

              # Iteratively remove broken files
              removed_count = 0
              while True:
                  current_removed = 0
                  to_remove = set()
                  
                  for f, deps in dependency_graph.items():
                      if f not in abs_files: 
                          continue
                          
                      for dep in deps:
                          if dep.startswith("MISSING:") or dep not in abs_files:
                              to_remove.add(f)
                              # print(f"Removing {os.path.relpath(f)} because of broken dependency {dep}")
                              break
                  
                  if not to_remove:
                      break
                  
                  for f in to_remove:
                      abs_files.remove(f)
                      current_removed += 1
                  
                  removed_count += current_removed
              
              print(f"Removed {removed_count} files with broken dependency chains (including skips).")
              print(f"Remaining valid files: {len(abs_files)}")
              
              with open('mojom_files_list.txt', 'w') as f:
                  for abs_p in abs_files:
                      # Convert back to relative path for tools
                      rel_p = os.path.relpath(abs_p, os.getcwd())
                      f.write(rel_p + '\n')

          if __name__ == '__main__':
              main()
          EOF
          
          python3 filter_mojoms.py
          
          echo "Final list for parser:"
          head -10 mojom_files_list.txt

          # Rename bindings.js to mojo_bindings.js as that is what is often expected, 
          # but keep original if needed by other files?
          # Actually, let's just copy it to mojo_bindings.js so we have the standard name
          cp chromium_src/mojo/public/js/bindings.js bindings/mojo_bindings.js
          
          echo "Core bindings copied."
          ls -la bindings/

      - name: Generate Mojo JS bindings
        run: |
          echo "Generating Mojo JS bindings using official generator..."
          
          # Set up paths
          export PYTHONPATH="$PYTHONPATH:$(pwd)/chromium_src"
          
          # Directory for bindings
          mkdir -p bindings
          
          # Create a Python script to drive the generation and indexing
          cat << 'SCRIPT' > generate_bindings.py
          import os
          import sys
          import json
          import subprocess
          import re
          from pathlib import Path
          
          def parse_mojom_file(file_path):
              """Basic regex-based parsing of mojom files to extract interface names and methods."""
              try:
                  with open(file_path, 'r', encoding='utf-8') as f:
                      content = f.read()
                  
                  module_match = re.search(r'module\s+([\w.]+);', content)
                  module = module_match.group(1) if module_match else 'unknown'
                  
                  interfaces = []
                  # Regex to find interfaces
                  # This is simplified and might miss some complex cases
                  interface_blocks = re.finditer(r'interface\s+(\w+)\s*{(.*?)}', content, re.DOTALL)
                  
                  for match in interface_blocks:
                      interface_name = match.group(1)
                      body = match.group(2)
                      
                      methods = []
                      # Find methods: name(args) => ...
                      # Very basic regex, assumes standard formatting
                      method_matches = re.finditer(r'(\w+)\s*\(', body)
                      for m in method_matches:
                          methods.append({'name': m.group(1)})
                          
                      interfaces.append({
                          'name': interface_name,
                          'methods': methods
                      })
                      
                  return {
                      'module': module,
                      'interfaces': interfaces
                  }
              except Exception as e:
                  print(f"Error parsing {file_path}: {e}")
                  return None

          def run_parser(mojom_files):
              """Run the mojom parser to generate -module files."""
              print("Running mojom parser...")
              # Create filelist for parser
              # We need to make sure we pass relative paths that make sense with the roots
              # But simple invocation often works best:
              
              # We use a temporary file for the list of files to parse
              with open('mojom_files_list.txt', 'w') as f:
                  for p in mojom_files:
                      f.write(f"{p}\n")
              
              cmd = [
                  sys.executable,
                  'chromium_src/mojo/public/tools/mojom/mojom_parser.py',
                  '--output-root', '.',
                  '--input-root', '.',
                  '--input-root', 'chromium_src', # Include path for imports to resolve
                  '--mojom-file-list', 'mojom_files_list.txt'
              ]
              
              try:
                  subprocess.run(cmd, check=True)
                  print("DEBUG: Listing generated module files:")
                  subprocess.run("find . -name '*.mojom-module' | head -n 20", shell=True)
                  return True
              except subprocess.CalledProcessError as e:
                  print(f"Parser failed: {e}")
                  return False

          def run_generator(mojom_path):
              """Run the official mojom bindings generator."""
          def run_generator(mojom_path):
              """Run the official mojom bindings generator."""
              # mojom_path is relative: chromium_src/foo/bar.mojom
              # We need to make sure RelativePath behaves correctly.
              # The generator internally converts args to absolute paths.
              # RelativePath(abs_path, abs_root, abs_output)
              
              # If we pass --depth . and --output_dir ., root is CWD.
              # absolute path of CWD/chromium_src/foo/bar.mojom starts with CWD.
              # But filename might be being passed weirdly.
              
              # Let's verify module path existence first
              # mojom_parser: --output-root . --input-root . 
              # implies module is at ./chromium_src/foo/bar.mojom-module
              module_path = mojom_path + '-module'
              if not os.path.exists(module_path):
                  print(f"DEBUG source module missing: {module_path}")
                  return False

              cmd = [
                  sys.executable,
                  'chromium_src/mojo/public/tools/bindings/mojom_bindings_generator.py',
                  '--use_bundled_pylibs',
                  'generate',
                  '-g', 'javascript',
                  '--output_dir', '.',
                  '--depth', '.', 
                  '--bytecode_path', 'bindings', 
                  mojom_path 
              ]
              try:
                  subprocess.run(cmd, check=True, capture_output=True)
                  return True
              except subprocess.CalledProcessError as e:
                  print(f"Failed to generate for {mojom_path}: {e.stderr.decode()}")
                  return False

          # Main execution
          bindings_dir = Path('bindings')
          bindings_dir.mkdir(exist_ok=True)
          
          index_data = {
              'generated_at': '',
              'interfaces': [],
              'files': []
          }
          
          import datetime
          index_data['generated_at'] = datetime.datetime.utcnow().isoformat() + 'Z'
          
          # Read mojom files list
          with open('mojom_files_list.txt', 'r') as f:
              mojom_files = [line.strip() for line in f if line.strip()]
          
          print(f"Processing {len(mojom_files)} .mojom files...")
          
          # Step 1: Parse all files
          if not run_parser(mojom_files):
               print("WARNING: Parsing failed. Generation might fail.")
          
          # Step 2: Generate bindings
          for mojom_path in mojom_files:
              # Run official generator
              if run_generator(mojom_path):
                  # Move generated files to bindings/ directory to flatten structure
                  # The generator outputs to {root}/{path/to/file}.js
                  # We want to move them to bindings/ and flatten them potentially, 
                  # OR keep structure but we need to know where they are.
                  # Let's see: if input is chromium_src/foo/bar.mojom
                  # output is chromium_src/foo/bar.mojom.js under --output_dir .
                  
                  # We want to move these to bindings/ directory
                  # Construct expected output path
                  src_path = Path(mojom_path)
                  gen_base = src_path.with_suffix('.mojom.js') # Standard bindings
                  gen_lite = src_path.with_suffix('.mojom-lite.js') # Lite bindings (what we want)
                  
                  if gen_lite.exists():
                      # Flattened name for bindings dir: third_party_blink_public_mojom_foo.mojom.js
                      # This avoids collisions and directory depth issues in the simple server
                      rel_path = str(src_path).replace('chromium_src/', '').replace('chromium_src\\', '')
                      flat_name = rel_path.replace('/', '_').replace('\\', '_').replace('.mojom', '.mojom.js')
                      
                      dest_lite = bindings_dir / flat_name
                      
                      # Copy/Move the lite binding to destination as the main file we use
                      import shutil
                      shutil.move(str(gen_lite), str(dest_lite))
                      
                      # Also move the HTML-formatted binding if it exists (useful for reading)
                      # shutil.move(str(gen_base), str(bindings_dir / (flat_name + '.full.js')))
                      
                      parsed = parse_mojom_file(mojom_path)
                      if parsed and parsed.get('interfaces'):
                          # Add to index
                          for interface in parsed['interfaces']:
                              index_data['interfaces'].append({
                                  'name': interface['name'],
                                  'module': parsed['module'],
                                  'file': flat_name, # Point to the lite binding
                                  'methods': [m['name'] for m in interface.get('methods', [])]
                              })
                          
                          index_data['files'].append({
                              'filename': flat_name,
                              'source': rel_path,
                              'module': parsed['module']
                          })
                          print(f"Index updated for: {flat_name}")
                  else:
                      print(f"Warning: Expected generated file not found: {gen_lite}")

          # Write index.json
          with open(bindings_dir / 'index.json', 'w') as f:
              json.dump(index_data, f, indent=2)
          
          print(f"\nIndexed {len(index_data['files'])} binding files")
          print(f"Total interfaces: {len(index_data['interfaces'])}")
          
          SCRIPT
          
          # Run the script
          python generate_bindings.py
          
      - name: Generate index.js
        run: |
          cat > bindings/index.js << 'EOF'
          // MojoJS Bindings Index
          // Auto-generated - Do not edit manually

          (function(global) {
            'use strict';

            // Create trusted types policy for script URLs
            let trustedPolicy = null;
            if (typeof window.trustedTypes !== 'undefined') {
              try {
                trustedPolicy = window.trustedTypes.createPolicy('mojoBindings', {
                  createScriptURL: (input) => input
                });
              } catch (e) {
                console.warn('Could not create trusted types policy:', e);
              }
            }

            const MojoBindings = {
              _indexData: null,
              _loadedModules: {},

              async loadIndex() {
                if (this._indexData) return this._indexData;
                const response = await fetch('./bindings/index.json');
                this._indexData = await response.json();
                return this._indexData;
              },

              async getInterfaces() {
                const data = await this.loadIndex();
                return data.interfaces;
              },

              async searchInterfaces(query) {
                const interfaces = await this.getInterfaces();
                const q = query.toLowerCase();
                return interfaces.filter(i => 
                  i.name.toLowerCase().includes(q) || 
                  i.module.toLowerCase().includes(q)
                );
              },

              async loadBinding(filename) {
                if (this._loadedModules[filename]) {
                  return this._loadedModules[filename];
                }
                return new Promise((resolve, reject) => {
                  const script = document.createElement('script');
                  const scriptUrl = `./bindings/${filename}`;
                  
                  if (trustedPolicy) {
                    script.src = trustedPolicy.createScriptURL(scriptUrl);
                  } else {
                    script.src = scriptUrl;
                  }
                  
                  script.onload = () => {
                    this._loadedModules[filename] = true;
                    resolve(true);
                  };
                  script.onerror = () => {
                    reject(new Error(`Failed to load binding: ${filename}`));
                  };
                  document.head.appendChild(script);
                });
              },

              getMetadata() {
                return this._indexData;
              }
            };

            global.MojoBindings = MojoBindings;
          })(typeof window !== 'undefined' ? window : this);
          EOF

      - name: Build Mojo JS core bindings
        run: |
          echo "Building Mojo JS core bindings..."
          # Concatenate files in order defined by BUILD.gn
          cat chromium_src/mojo/public/js/base.js \
              chromium_src/mojo/public/js/bindings.js \
              chromium_src/mojo/public/js/interface_types.js \
              chromium_src/mojo/public/js/lib/buffer.js \
              chromium_src/mojo/public/js/lib/codec.js \
              chromium_src/mojo/public/js/lib/connector.js \
              chromium_src/mojo/public/js/lib/control_message_handler.js \
              chromium_src/mojo/public/js/lib/control_message_proxy.js \
              chromium_src/mojo/public/js/lib/interface_endpoint_client.js \
              chromium_src/mojo/public/js/lib/interface_endpoint_handle.js \
              chromium_src/mojo/public/js/lib/pipe_control_message_handler.js \
              chromium_src/mojo/public/js/lib/pipe_control_message_proxy.js \
              chromium_src/mojo/public/js/lib/router.js \
              chromium_src/mojo/public/js/lib/unicode.js \
              chromium_src/mojo/public/js/lib/validator.js \
              > bindings/mojo_bindings.js
          
          # Append generated system mojoms if they exist (using wildcard to avoid failure if missing)
          # These are usually in bindings/ folder after generation
          if ls bindings/*interface_control_messages.mojom.js 1> /dev/null 2>&1; then
             cat bindings/*interface_control_messages.mojom.js >> bindings/mojo_bindings.js
          fi
          if ls bindings/*pipe_control_messages.mojom.js 1> /dev/null 2>&1; then
             cat bindings/*pipe_control_messages.mojom.js >> bindings/mojo_bindings.js
          fi

          echo "Core bindings built."
          ls -la bindings/mojo_bindings.js

      - name: Cleanup temporary files
        run: |
          # Remove all temporary files that should NOT be committed
          rm -rf chromium_src/
          rm -f mojom_files.txt
          echo "Cleaned up temporary files"

      - name: Commit only generated binding files
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Explicitly add ONLY the generated binding files
          git add bindings/*.mojom.js
          git add bindings/index.js
          git add bindings/index.json
          # Add the copied core bindings
          git add bindings/mojo_bindings.js
          git add bindings/*.js
          
          # Show what will be committed
          echo "Files staged for commit:"
          git diff --staged --name-only
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            CHANGED_COUNT=$(git diff --staged --name-only | wc -l)
            git commit -m "Update Mojo JS bindings - $(date -u +%Y-%m-%d) [$CHANGED_COUNT files]"
            git push
          fi
