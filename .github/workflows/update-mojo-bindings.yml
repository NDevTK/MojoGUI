name: Update Mojo JS Bindings

on:
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday at midnight UTC
  workflow_dispatch:  # Manual trigger
  push:
    branches: [main]
    paths:
      - '.github/workflows/update-mojo-bindings.yml'

permissions:
  contents: write

jobs:
  update-bindings:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Create working directories
        run: |
          mkdir -p chromium_src
          mkdir -p bindings

      - name: Sparse checkout .mojom files from Chromium
        run: |
          cd chromium_src
          git init
          git remote add origin https://chromium.googlesource.com/chromium/src.git
          git config core.sparseCheckout true
          
          # Use universal pattern to get ALL .mojom files regardless of location
          # Also get mojo/public for base types and dependencies
          cat > .git/info/sparse-checkout << 'EOF'
          mojo/public/
          **/*.mojom
          EOF
          
          git pull --depth=1 origin main || git pull --depth=1 origin master

      - name: List .mojom files
        run: |
          # Finds all .mojom files in chromium_src
          # We sort them to help with stability, though dependencies matter more
          find chromium_src -name "*.mojom" | sort > mojom_files.txt
          
          echo "Found $(wc -l < mojom_files.txt) .mojom files"
          head -10 mojom_files.txt

      - name: Generate Mojo JS bindings
        run: |
          echo "Generating Mojo JS bindings..."
          
          # Set up paths
          export PYTHONPATH="$PYTHONPATH:$(pwd)/chromium_src"
          
          # Directory for bindings
          mkdir -p bindings
          
          # Create a Python script to drive the generation
          cat << 'SCRIPT' > generate_bindings.py
          import os
          import json
          import re
          import datetime
          from pathlib import Path

          # Configuration
          ROOT_DIR = 'chromium_src'

          TYPE_MAPPING = {
              'bool': 'mojo.internal.Bool',
              'int8': 'mojo.internal.Int8',
              'int16': 'mojo.internal.Int16',
              'int32': 'mojo.internal.Int32',
              'int64': 'mojo.internal.Int64',
              'uint8': 'mojo.internal.Uint8',
              'uint16': 'mojo.internal.Uint16',
              'uint32': 'mojo.internal.Uint32',
              'uint64': 'mojo.internal.Uint64',
              'float': 'mojo.internal.Float',
              'double': 'mojo.internal.Double',
              'string': 'mojo.internal.String',
              'handle': 'mojo.internal.Handle',
          }

          def parse_mojom_file(file_path):
              """Parse a .mojom file and extract interface definitions using regex."""
              try:
                  with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                      content = f.read()
              except Exception as e:
                  return None


              result = {
                  'path': str(file_path),
                  'module': None,
                  'imports': [],
                  'interfaces': [],
                  'structs': [],
                  'unions': [],
                  'enums': [],
                  'constants': []
              }

              # Extract module name
              module_match = re.search(r'module\s+([\w.]+)\s*;', content)
              if module_match:
                  result['module'] = module_match.group(1)

              # Extract imports
              imports = re.findall(r'import\s+"([^"]+)"', content)
              result['imports'] = imports

              # Remove comments for cleaner parsing
              content_no_comments = re.sub(r'//[^\n]*', '', content)
              content_no_comments = re.sub(r'/\*.*?\*/', '', content_no_comments, flags=re.DOTALL)

              # Extract interfaces with their methods
              interface_pattern = r'interface\s+(\w+)\s*\{'
              for match in re.finditer(interface_pattern, content_no_comments):
                  interface_name = match.group(1)
                  start_pos = match.end()
                  
                  # Find matching closing brace
                  brace_count = 1
                  end_pos = start_pos
                  while brace_count > 0 and end_pos < len(content_no_comments):
                      if content_no_comments[end_pos] == '{':
                          brace_count += 1
                      elif content_no_comments[end_pos] == '}':
                          brace_count -= 1
                      end_pos += 1
                  
                  interface_body = content_no_comments[start_pos:end_pos-1]
                  
                  methods = []
                  # Capture optional Ordinal: Name@123(...)
                  method_pattern = r'([A-Z][a-zA-Z0-9_]*)(?:@(\d+))?\s*\(([^)]*)\)\s*(?:=>\s*\(([^)]*)\))?'
                  for method_match in re.finditer(method_pattern, interface_body):
                      method_name = method_match.group(1)
                      ordinal_str = method_match.group(2)
                      params_str = method_match.group(3).strip()
                      returns_str = method_match.group(4)
                      
                      # Skip false positives
                      if method_name in ('TODO', 'NOTE', 'FIXME', 'DEPRECATED', 'If', 'For', 'While', 'Switch'):
                          continue
                      
                      params = parse_params(params_str) if params_str else []
                      returns = parse_params(returns_str) if returns_str is not None else None
                      
                      methods.append({
                          'name': method_name,
                          'ordinal': int(ordinal_str) if ordinal_str else None,
                          'params': params,
                          'returns': returns,
                          'is_one_way': returns is None
                      })
                  
                  # Deduplicate methods
                  seen = set()
                  unique_methods = []
                  for m in methods:
                      if m['name'] not in seen:
                          seen.add(m['name'])
                          unique_methods.append(m)
                  
                  result['interfaces'].append({
                      'name': interface_name,
                      'methods': unique_methods
                  })

              # Extract enums
              enum_pattern = r'enum\s+(\w+)\s*\{([^}]*)\}'
              for match in re.finditer(enum_pattern, content_no_comments, re.DOTALL):
                  enum_name = match.group(1)
                  enum_body = match.group(2)
                  values = []
                  for line in enum_body.split(','):
                      line = line.strip()
                      if line:
                          # Match name and optional value
                          val_match = re.search(r'([a-zA-Z_]\w*)(?:\s*=\s*(.*?))?$', line)
                          if val_match:
                              v_name = val_match.group(1)
                              v_val = val_match.group(2).strip() if val_match.group(2) else None
                              values.append({'name': v_name, 'value': v_val})
                  result['enums'].append({'name': enum_name, 'values': values})

              # Extract structs
              struct_pattern = r'struct\s+(\w+)\s*\{([^}]*)\}'
              for match in re.finditer(struct_pattern, content_no_comments, re.DOTALL):
                  struct_name = match.group(1)
                  struct_body = match.group(2)
                  fields = parse_params(struct_body)
                  result['structs'].append({'name': struct_name, 'fields': fields})

              # Extract constants (module level)
              const_pattern = r'const\s+([\w\.]+)\s+(\w+)\s*=\s*([^;]+);'
              for match in re.finditer(const_pattern, content_no_comments):
                  c_type = match.group(1)
                  c_name = match.group(2)
                  c_value = match.group(3).strip()
                  result['constants'].append({'name': c_name, 'type': c_type, 'value': c_value})

              # Extract unions
              union_pattern = r'union\s+(\w+)\s*\{([^}]*)\}'
              for match in re.finditer(union_pattern, content_no_comments, re.DOTALL):
                  union_name = match.group(1)
                  union_body = match.group(2)
                  fields = parse_params(union_body)
                  # Unions in Mojo have ordinals, often explicit. parse_params handles basic "Type Name".
                  # We need to ensure ordinals are parsed if possible, or auto-assigned.
                  # For now, simple parsing is enough as we reuse parse_params.
                  result['unions'].append({'name': union_name, 'fields': fields})

              return result

          def parse_params(params_str):
              """Parse parameter string into list of param objects."""
              if not params_str:
                  return []
              
              params = []
              depth = 0
              current = ""
              for char in params_str:
                  if char in '<([':
                      depth += 1
                  elif char in '>)]':
                      depth -= 1
                  elif (char == ',' or char == ';') and depth == 0:
                      if current.strip():
                          p = parse_single_param(current.strip())
                          if p:
                              params.append(p)
                      current = ""
                      continue
                  current += char
              
              if current.strip():
                  p = parse_single_param(current.strip())
                  if p:
                      params.append(p)
              
              return params

          def parse_single_param(param_str):
              """Parse a single parameter like 'string name'."""
              param_str = param_str.strip()
              if not param_str:
                  return None
              
              param_str = re.sub(r'//.*$', '', param_str, flags=re.MULTILINE).strip()
              
              # Extract MinVersion
              min_version_match = re.search(r'\[MinVersion=(\d+)\]', param_str)
              min_version = int(min_version_match.group(1)) if min_version_match else 0
              param_str = re.sub(r'\[.*?\]', '', param_str).strip() # Remove attributes
              
              ordinal_match = re.search(r'@(\d+)', param_str)
              ordinal = int(ordinal_match.group(1)) if ordinal_match else None
              param_str = re.sub(r'@\d+', '', param_str).strip() # Remove explicit ordinals
              
              param_str = re.sub(r'=.*$', '', param_str).strip()
              param_str = param_str.rstrip(';').strip()
              
              if not param_str:
                  return None
              
              optional = '?' in param_str
              param_str = param_str.replace('?', '').strip()
              
              if param_str.endswith('&'):
                  param_str = f"pending_receiver<{param_str[:-1].strip()}>"
              
              parts = param_str.split()
              if len(parts) >= 2:
                  param_type = ' '.join(parts[:-1])
                  param_name = parts[-1]
              elif len(parts) == 1:
                  param_type = parts[0]
                  param_name = ""
              else:
                  return None
              
              if param_name and not re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', param_name):
                  return None
              
              return {'type': param_type, 'name': param_name, 'optional': optional, 'ordinal': ordinal, 'min_version': min_version}

          def to_camel_case(name):
              """Convert PascalCase to camelCase."""
              if name and name[0].isupper():
                  return name[0].lower() + name[1:]
              components = name.split('_')
              return components[0] + ''.join(x.title() for x in components[1:])

          def mojo_type_map(mojom_type):
              """Map mojom types to mojo.internal types."""
              type_clean = mojom_type.replace('?', '').strip()
              
              # Check for arrays
              if type_clean.startswith('array<'):
                  return 'mojo.internal.Array'
              
              # Check for maps
              if type_clean.startswith('map<'):
                  return 'mojo.internal.Map'
              
              # Check for pending_receiver/pending_remote
              if type_clean.startswith('pending_receiver<'):
                  return 'mojo.internal.InterfaceRequest'
              if type_clean.startswith('pending_remote<'):
                  return 'mojo.internal.InterfaceProxy'
              if type_clean.startswith('pending_associated_receiver<'):
                  return 'mojo.internal.AssociatedInterfaceRequest'
              if type_clean.startswith('pending_associated_remote<'):
                  return 'mojo.internal.AssociatedInterfaceProxy'
              
              # Look up in type map
              if type_clean in TYPE_MAPPING:
                  return TYPE_MAPPING[type_clean]
              
              # For unknown types (likely structs/enums), default to pointer
              return 'mojo.internal.Pointer'


          def generate_js_binding(parsed, global_kind_map={}):
              """Generate JavaScript binding code that works with the Mojo runtime."""
              if not parsed or not parsed.get('module'):
                  return None
              
              module = parsed['module']
              module_parts = module.split('.')
              
              # Build set of valid types for this module
              valid_types = set()
              for s in parsed.get('structs', []): valid_types.add(s['name'])
              for e in parsed.get('enums', []): valid_types.add(e['name'])
              
              # Map imports to their module namespaces (naive mapping)
              # Standard Mojo mapping: "foo/bar/baz.mojom" -> "baz.mojom" -> "baz.mojom.Type"
              # We need to be smarter. For now, assume if it looks like a Type, it might be one.
              
              def resolve_mojo_type(type_name):
                  # Recursive parsing for complex types (Array/Map)
                  type_name = type_name.strip()
                  
                  if type_name.startswith('array<'):
                      is_nullable = False
                      if type_name.endswith('?'):
                          is_nullable = True
                          type_name = type_name[:-1].strip()
                      
                      # Extract inner type
                      inner = type_name[6:-1].strip()
                      return f"mojo.internal.Array({resolve_mojo_type(inner)}, {'true' if is_nullable else 'false'})"

                  if type_name.startswith('map<'):
                      is_nullable = False
                      if type_name.endswith('?'):
                          is_nullable = True
                          type_name = type_name[:-1].strip()
                      
                      content = type_name[4:-1].strip()
                      # Split by comma respecting nested brackets
                      depth = 0
                      comma_idx = -1
                      for i, char in enumerate(content):
                          if char == '<': depth += 1
                          elif char == '>': depth -= 1
                          elif char == ',' and depth == 0:
                              comma_idx = i
                              break
                      
                      if comma_idx != -1:
                          key_type = content[:comma_idx].strip()
                          val_type = content[comma_idx+1:].strip()
                          return f"mojo.internal.Map({resolve_mojo_type(key_type)}, {resolve_mojo_type(val_type)}, {'true' if is_nullable else 'false'})"
                      # Fallback if parsing fails
                      return 'mojo.internal.Map'

                  # Basic types
                  if type_name in TYPE_MAPPING:
                       return TYPE_MAPPING[type_name]
                  
                  # Recursive handling for pending types
                  if type_name.startswith('pending_remote<'):
                      inner = type_name[15:-1].strip()
                      # Return InterfaceProxy(...) directly but tell recursive call not to wrap
                      return f"mojo.internal.InterfaceProxy({resolve_mojo_type_raw(inner)})"
                  
                  if type_name.startswith('pending_receiver<'):
                      inner = type_name[17:-1].strip()
                      return f"mojo.internal.InterfaceRequest({resolve_mojo_type_raw(inner)})"
                  
                  if type_name.startswith('pending_associated_remote<'):
                      inner = type_name[26:-1].strip()
                      return f"mojo.internal.AssociatedInterfaceProxy({resolve_mojo_type_raw(inner)})"
 
                  if type_name.startswith('pending_associated_receiver<'):
                      inner = type_name[28:-1].strip()
                      return f"mojo.internal.AssociatedInterfaceRequest({resolve_mojo_type_raw(inner)})"

                  # Check local types
                  clean_name = type_name.replace('?', '').strip()
                  
                  # Determine fully qualified name to check kind
                  fq_name = f"{module}.{clean_name}"
                  kind = global_kind_map.get(fq_name) or global_kind_map.get(clean_name)
                  
                  suffix = 'Spec'
                  is_iface = False
                  if kind == 'interface':
                      suffix = 'Remote'
                      is_iface = True
                  
                  res_type = ""
                  if clean_name in valid_types:
                      res_type = f"{current_ns}.{clean_name}{suffix}"
                  elif '.' in clean_name:
                      res_type = f"{clean_name}{suffix}"
                  elif clean_name and clean_name[0].isupper() and clean_name not in TYPE_MAPPING:
                      # Heuristic: Uppercase unqualified
                      res_type = f"{current_ns}.{clean_name}{suffix}"
                  else:
                      return 'mojo.internal.Pointer'
                  
                  if is_iface:
                      return f"mojo.internal.InterfaceProxy({res_type})"
                  return res_type

              def resolve_mojo_type_raw(type_name):
                  """Helper to get the raw Spec/Remote name without Proxy/Request wrappers."""
                  type_name = type_name.strip()
                  clean_name = type_name.replace('?', '').strip()
                  
                  # Basics
                  if type_name in TYPE_MAPPING: return TYPE_MAPPING[type_name]
                  
                  fq_name = f"{module}.{clean_name}"
                  kind = global_kind_map.get(fq_name) or global_kind_map.get(clean_name)
                  
                  suffix = 'Spec'
                  if kind == 'interface': suffix = 'Remote'
                  
                  if clean_name in valid_types:
                      return f"{current_ns}.{clean_name}{suffix}"
                  elif '.' in clean_name:
                      return f"{clean_name}{suffix}"
                  elif clean_name and clean_name[0].isupper():
                      return f"{current_ns}.{clean_name}{suffix}"
                  return 'mojo.internal.Pointer'

              def get_struct_layout(params):
                  """Calculate field offsets and size using Mojo's Best Fit algorithm."""
                  
                  # 1. Expand Nullable Primitives (int32? -> bool + int32)
                  expanded_params = []
                  ordinal_counter = 0
                  
                  for param in params:
                      if not param or not param.get('name'): continue
                      
                      p_type = resolve_mojo_type(param.get('type', 'string'))
                      is_nullable = param.get('optional') or '?' in param.get('type', '')
                      ordinal = param.get('ordinal')
                      if ordinal is None:
                          ordinal = ordinal_counter
                      ordinal_counter = ordinal + 1
                      min_version = param.get('min_version', 0)
                      
                      # Check if this is a nullable primitive (not pointer/handle)
                      is_pointer = p_type == 'mojo.internal.String' or p_type.startswith('mojo.internal.Array') or p_type.startswith('mojo.internal.Map') or p_type.endswith('Spec') or p_type.startswith('mojo.internal.Interface')
                      # Handle/Encoding types are 4 bytes but treated as opaque
                      
                      # Simplification: If it's a primitive number/bool and nullable, split it.
                      is_primitive = p_type in ('mojo.internal.Bool', 'mojo.internal.Int8', 'mojo.internal.Uint8', 'mojo.internal.Int16', 'mojo.internal.Uint16', 'mojo.internal.Int32', 'mojo.internal.Uint32', 'mojo.internal.Int64', 'mojo.internal.Uint64', 'mojo.internal.Float', 'mojo.internal.Double')
                      
                      if is_nullable and is_primitive:
                          # Split!
                          # 1. HasValue (Bool)
                          expanded_params.append({
                              'name': f"{param['name']}_$flag",
                              'type': 'mojo.internal.Bool',
                              'original_name': param['name'],
                              'original_type': p_type,
                              'is_flag': True,
                              'ordinal': ordinal,
                              'sub_ordinal': 0,
                              'min_version': min_version,
                              'nullable': False # The flag itself is not nullable
                          })
                          # 2. Value (Primitive, Un-nullable kind)
                          expanded_params.append({
                              'name': f"{param['name']}_$value",
                              'type': p_type,
                              'original_name': param['name'],
                              'is_value': True,
                              'ordinal': ordinal,
                              'sub_ordinal': 1,
                              'min_version': min_version,
                              'nullable': False # The value storage is not nullable
                          })
                      else:
                          # Normal field
                          expanded_params.append({
                              'name': param['name'],
                              'type': p_type,
                              'original_name': param['name'],
                              'ordinal': ordinal,
                              'sub_ordinal': 0,
                              'min_version': min_version,
                              'nullable': is_nullable
                          })
                  
                  # 2. Sort by Ordinal (Temporary, will resort by size for packing)
                  expanded_params.sort(key=lambda x: (x['ordinal'], x['sub_ordinal']))
                  
                  # 3. Best Fit Algorithm
                  packed_fields = []
                  
                  def get_size_alignment(p_type):
                      if p_type == 'mojo.internal.Bool': return 1, 1 # Bit packed later
                      if p_type in ('mojo.internal.Int8', 'mojo.internal.Uint8'): return 1, 1
                      if p_type in ('mojo.internal.Int16', 'mojo.internal.Uint16'): return 2, 2
                      if p_type in ('mojo.internal.Int32', 'mojo.internal.Uint32', 'mojo.internal.Float', 'mojo.internal.InterfaceRequest', 'mojo.internal.AssociatedInterfaceRequest', 'mojo.internal.Handle'): return 4, 4
                      if p_type in ('mojo.internal.Int64', 'mojo.internal.Uint64', 'mojo.internal.Double', 'mojo.internal.InterfaceProxy', 'mojo.internal.AssociatedInterfaceProxy'): return 8, 8
                      # Pointers
                      spec_name = p_type.replace('Spec', '')
                      kind = global_kind_map.get(spec_name)
                      if kind == 'enum': return 4, 4
                      if kind == 'union': return 16, 8
                      return 8, 8
                  
                  def get_pad(offset, alignment):
                      return (alignment - (offset % alignment)) % alignment

                  def get_field_offset(src_field, last_field):
                      # If trying to pack Bool after Bool in same byte
                      if (src_field['type'] == 'mojo.internal.Bool' and 
                          last_field['type'] == 'mojo.internal.Bool' and
                          last_field['bit'] < 7 and
                          src_field['offset'] is None): # Only if not already placed
                          # Special case handled by logic below, but here we calculate space.
                          # Actually, Best Fit iterates through *Packed* fields.
                          pass
                      
                      start = last_field['offset'] + last_field['size']
                      pad = get_pad(start, src_field['alignment'])
                      return start + pad

                  # Initialize fields with size/alignment
                  for p in expanded_params:
                      size, align = get_size_alignment(p['type'])
                      p['size'] = size
                      p['alignment'] = align
                      p['offset'] = None
                      p['bit'] = 0
                  
                  # CRITICAL: Sort by Version (Ascending), then Size (Descending)
                  # This ensures V0 fields are packed first, and within each version, large fields come first.
                  # This matches pack.py behavior and prevents data corruption across versions.
                  expanded_params.sort(key=lambda x: (x['min_version'], -x['size'], x['ordinal'], x['sub_ordinal']))
                  
                  if not expanded_params:
                      return [], 8, "[{version: 0, packedSize: 8}]"

                  # First field always at 0
                  first = expanded_params[0]
                  first['offset'] = 0
                  first['bit'] = 0
                  packed_fields.append(first)
                  
                  # Pack remaining fields
                  for src in expanded_params[1:]:
                      placed = False
                      
                      # Try to fit in holes provided by existing fields
                      # Iterate through gaps between packed_fields
                      
                      # Special Bool Packing Check first?
                      # If src is Bool, try to pack into ANY existing Bool that has space
                      if src['type'] == 'mojo.internal.Bool':
                          for dst in packed_fields:
                              if dst['type'] == 'mojo.internal.Bool' and dst['bit'] < 7:
                                  # Check if this byte is "open" for this version? 
                                  # Assuming versions allow packing.
                                  src['offset'] = dst['offset']
                                  src['bit'] = dst['bit'] + 1
                                  # Update the dst bit count to reserve it? 
                                  # Simpler: Just increment bit count of "byte owner" or track used bits map.
                                  # Let's just find the latest bool in this byte.
                                  
                                  # Better: Find all bools at this offset. Max bit.
                                  bools_at_offset = [f for f in packed_fields if f['offset'] == dst['offset'] and f['type'] == 'mojo.internal.Bool']
                                  max_bit = max(f['bit'] for f in bools_at_offset)
                                  if max_bit < 7:
                                      src['offset'] = dst['offset']
                                      src['bit'] = max_bit + 1
                                      # Insert in list order
                                      # Find index of last bool at this offset
                                      idx = packed_fields.index(bools_at_offset[-1])
                                      packed_fields.insert(idx + 1, src)
                                      placed = True
                                      break
                          if placed: continue

                      # Find hole
                      # Check gap before first field? (Should be 0 if header is separate)
                      # Check gaps between fields
                      for i in range(len(packed_fields) + 1):
                          prev = packed_fields[i-1] if i > 0 else None
                          curr = packed_fields[i] if i < len(packed_fields) else None
                          
                          start = 0
                          if prev:
                              start = prev['offset'] + prev['size']
                          
                          # Proposed offset
                          pad = get_pad(start, src['alignment'])
                          proposed_offset = start + pad
                          
                          end_limit = curr['offset'] if curr else float('inf')
                          
                          if proposed_offset + src['size'] <= end_limit:
                              # Fits!
                              src['offset'] = proposed_offset
                              src['bit'] = 0
                              packed_fields.insert(i, src)
                              placed = True
                              break
                      
                      if not placed:
                          # Append to end
                          last = packed_fields[-1]
                          start = last['offset'] + last['size']
                          pad = get_pad(start, src['alignment'])
                          src['offset'] = start + pad
                          src['bit'] = 0
                          packed_fields.append(src)

                  
                  # 4. Generate JavaScript Argument Lists for StructField
                  packed_fields.sort(key=lambda x: (x['ordinal'], x['sub_ordinal']))
                  fields_code = []
                  for f in packed_fields:
                      # Determine DEFAULT VALUE
                      default_val = "null"
                      if f['type'] == 'mojo.internal.Bool': default_val = "false"
                      elif f['type'] in ('mojo.internal.Int8', 'mojo.internal.Uint8', 'mojo.internal.Int16', 'mojo.internal.Uint16', 'mojo.internal.Int32', 'mojo.internal.Uint32', 'mojo.internal.Int64', 'mojo.internal.Uint64', 'mojo.internal.Float', 'mojo.internal.Double'):
                          default_val = "0"
                      
                      # Nullable props
                      props_js = "undefined"
                      if f.get('is_flag'):
                          props_js = f"{{ isPrimary: true, linkedValueFieldName: '{f['original_name']}_$value', originalFieldName: '{f['original_name']}' }}"
                      elif f.get('is_value'):
                          props_js = f"{{ isPrimary: false, linkedValueFieldName: '{f['original_name']}_$flag', originalFieldName: '{f['original_name']}' }}"

                      arg_list = [
                          f"'{f['name']}'",
                          f"{f['offset']}",
                          f"{f['bit']}",
                          f"{f['type']}",
                          default_val,
                          "true" if f['nullable'] else "false",
                          f"{f['min_version']}",
                          props_js
                      ]
                      fields_code.append(", ".join(arg_list))
                  
                  # 5. Calculate Versions
                  # The logic for versions needs to be based on the *packed* fields,
                  # and their final offsets.
                  
                  # Sort fields by min_version to determine version boundaries
                  # and then by offset to correctly calculate packedSize for each version.
                  sorted_fields_for_versions = sorted(packed_fields, key=lambda x: (x['min_version'], x['offset']))
                  
                  versions = []
                  current_version = -1
                  current_max_offset = 0
                  
                  # Ensure version 0 is always present, even if no fields.
                  # The base size is 8 bytes for the struct header.
                  versions.append([0, 8]) 
                  
                  for field in sorted_fields_for_versions:
                      field_ver = field.get('min_version', 0)
                      field_end_offset = field['offset'] + field['size']
                      
                      # If this field introduces a new version
                      if field_ver > current_version:
                          # Finalize the previous version's size if it exists and was updated
                          if current_version != -1:
                              # Align previous version's max_offset to 8 bytes
                              aligned_max_offset = current_max_offset
                              if aligned_max_offset % 8 != 0:
                                  aligned_max_offset += (8 - (aligned_max_offset % 8))
                              versions[-1][1] = 8 + aligned_max_offset # Header + aligned size
                          
                          # Start a new version entry
                          versions.append([field_ver, 0]) # Placeholder for size
                          current_version = field_ver
                          current_max_offset = field_end_offset
                      else:
                          # Continue with the current version, update max offset if needed
                          if field_end_offset > current_max_offset:
                              current_max_offset = field_end_offset
                  
                  # Finalize the last version's size
                  if versions:
                      aligned_max_offset = current_max_offset
                      if aligned_max_offset % 8 != 0:
                          aligned_max_offset += (8 - (aligned_max_offset % 8))
                      versions[-1][1] = 8 + aligned_max_offset # Header + aligned size
                  
                  # Remove duplicate version 0 if it was added twice (once initially, once by loop)
                  if len(versions) > 1 and versions[0][0] == 0 and versions[1][0] == 0:
                      versions.pop(0)
                  
                  # If no fields, ensure version 0, size 8
                  if not sorted_fields_for_versions and not versions:
                      versions = [[0, 8]]
                  
                  # Format versions as JS array of arrays (e.g. [[0, 40]])
                  versions_code = "[" + ", ".join([f"[{v[0]}, {v[1]}]" for v in versions]) + "]"

                  # Final struct size is the size of the latest version
                  packed_size = versions[-1][1] if versions else 8
                  
                  return fields_code, packed_size, versions_code

              
              # Build namespace chain
              js_code = f'''// Auto-generated MojoJS binding
          // Source: {parsed['path']}
          // Module: {module}

          'use strict';

          // Module namespace
          var {module_parts[0]} = {module_parts[0]} || {{}};
          '''
              
              current_ns = module_parts[0]
              for part in module_parts[1:]:
                  js_code += f"{current_ns}.{part} = {current_ns}.{part} || {{}};\n"
                  current_ns += f".{part}"
              
              # Declare external namespaces from imports (heuristic)
              # e.g., import "third_party/blink/..." -> var blink = blink || {};
              for imp in parsed.get('imports', []):
                  parts = imp.split('/')
                  # Common roots: blink, ui, gfx, skia, url
                  if 'blink' in parts: js_code += "var blink = blink || {};\n"
                  if 'ui' in parts: js_code += "var ui = ui || {};\n"
                  if 'gfx' in parts: js_code += "var gfx = gfx || {};\n"
                  if 'skia' in parts: js_code += "var skia = skia || {};\n"
                  if 'url' in parts: js_code += "var url = url || {};\n"
                  if 'content' in parts: js_code += "var content = content || {};\n"
                  if 'ash' in parts: js_code += "var ash = ash || {};\n"
                  if 'chromeos' in parts: js_code += "var chromeos = chromeos || {};\n"
                  if 'components' in parts: js_code += "var components = components || {};\n"
                  if 'services' in parts: js_code += "var services = services || {};\n"
              
              js_code += "\n"
              
              # Pre-declare all Spec objects to handle circular dependencies
              for enum in parsed.get('enums', []):
                  js_code += f"{current_ns}.{enum['name']}Spec = {{ $: mojo.internal.Enum() }};\n"
              for union in parsed.get('unions', []):
                  js_code += f"{current_ns}.{union['name']}Spec = {{ $: {{}} }};\n"
              for struct in parsed.get('structs', []):
                  js_code += f"{current_ns}.{struct['name']}Spec = {{ $: {{}} }};\n"
              for interface in parsed.get('interfaces', []):
                  iface_name = interface['name']
                  js_code += f"{current_ns}.{iface_name} = {{}};\n"
                  js_code += f"{current_ns}.{iface_name}.$interfaceName = '{module}.{iface_name}';\n"
                  for method in interface.get('methods', []):
                      js_code += f"{current_ns}.{iface_name}_{method['name']}_ParamsSpec = {{ $: {{}} }};\n"
                      if not method.get('is_one_way'):
                          js_code += f"{current_ns}.{iface_name}_{method['name']}_ResponseParamsSpec = {{ $: {{}} }};\n"

              # Generate constants
              for const in parsed.get('constants', []):
                  js_code += f"\n{current_ns}.{const['name']} = {const['value']};\n"

              # Generate enums
              for enum in parsed.get('enums', []):
                  js_code += f"\n// Enum: {enum['name']}\n"
                  js_code += f"{current_ns}.{enum['name']} = {{\n"
                  last_val = -1
                  for entry in enum['values']:
                      v_name = entry['name']
                      v_val = entry['value']
                      if v_val is not None:
                          try:
                              last_val = int(v_val, 0)
                          except:
                              pass # Could be another constant reference, but we prefer literal
                      else:
                          last_val += 1
                      js_code += f"  {v_name}: {last_val},\n"
                  js_code += "};\n"
                  # EnumSpec already pre-declared



              # Generate unions
              for union in parsed.get('unions', []):
                  union_name = union['name']
                  full_name = f"{current_ns}.{union_name}"
                  
                  js_code += f"\n// Union: {union_name}\n"
                  js_code += f"mojo.internal.Union(\n"
                  js_code += f"    {full_name}Spec, '{module}.{union_name}', {{\n"
                  
                  for i, field in enumerate(union['fields']):
                      f_type = resolve_mojo_type(field['type'])
                      f_ordinal = field.get('ordinal', i) # Fallback to index if no ordinal
                      if f_ordinal is None: f_ordinal = i
                      
                      f_nullable = 'true' if field.get('optional') or '?' in field.get('type', '') else 'false'
                      js_code += f"      '{field['name']}': {{\n"
                      js_code += f"        'ordinal': {f_ordinal},\n"
                      js_code += f"        'type': {f_type},\n"
                      js_code += f"        'nullable': {f_nullable},\n"
                      js_code += "      },\n"
                      
                  js_code += "    });\n"

              # Generate structs
              for struct in parsed.get('structs', []):
                  struct_name = struct['name']
                  full_name = f"{current_ns}.{struct_name}"
                  fields_code, packed_size, versions_code = get_struct_layout(struct.get('fields', []))
                  
                  js_code += f"\n// Struct: {struct_name}\n"
                  js_code += f"mojo.internal.Struct(\n"
                  js_code += f"    {full_name}Spec, '{module}.{struct_name}', [\n"
                  for field in fields_code:
                      js_code += f"      mojo.internal.StructField({field}),\n"
                  js_code += f"    ],\n"
                  js_code += f"    {versions_code});\n"
              
              # Generate interface classes with proper getRemote() method
              for interface in parsed.get('interfaces', []):
                  iface_name = interface['name']
                  full_name = f"{current_ns}.{iface_name}"
                  interface_string = f"{module}.{iface_name}"
                  
                  # Interface object already pre-declared bit metadata added
                  js_code += f"\n// Interface: {iface_name}\n"
                  
                  # Generate Method Structs (Params & Responses)
                  for method in interface.get('methods', []):
                      method_name = method['name']
                      
                      # Request Params
                      params = method.get('params', [])
                      param_struct_name = f"{iface_name}_{method_name}_Params"
                      p_fields, p_size, p_versions = get_struct_layout(params)
                      
                      js_code += f"mojo.internal.Struct(\n"
                      js_code += f"    {current_ns}.{param_struct_name}Spec, '{module}.{param_struct_name}', [\n"
                      for field in p_fields:
                          js_code += f"      mojo.internal.StructField({field}),\n"
                      js_code += f"    ],\n"
                      js_code += f"    {p_versions});\n\n"

                      # Response Params
                      if not method.get('is_one_way'):
                          resp_params = method.get('returns', [])
                          resp_struct_name = f"{iface_name}_{method_name}_ResponseParams"
                          r_fields, r_size, r_versions = get_struct_layout(resp_params)
                          
                          js_code += f"mojo.internal.Struct(\n"
                          js_code += f"    {current_ns}.{resp_struct_name}Spec, '{module}.{resp_struct_name}', [\n"
                          for field in r_fields:
                              js_code += f"      mojo.internal.StructField({field}),\n"
                          js_code += f"    ],\n"
                          js_code += f"    {r_versions});\n\n"

                  # Generate PendingReceiver class first (needed by Remote)
                  
                  # Generate PendingReceiver class first (needed by Remote)
                  js_code += f"{full_name}PendingReceiver = class {{\n"
                  js_code += "  constructor(handle) {\n"
                  js_code += "    this.handle = handle;\n"
                  js_code += "  }\n"
                  js_code += "};\n\n"
                  
                  # Generate Remote class with getRemote() static method
                  js_code += f"{full_name}Remote = class {{\n"
                  js_code += f"  static get $interfaceName() {{\n"
                  js_code += f"    return '{interface_string}';\n"
                  js_code += "  }\n\n"
                  
                  js_code += "  constructor(handle = undefined) {\n"
                  js_code += f"    this.proxy = new mojo.internal.interfaceSupport.InterfaceRemoteBase(\n"
                  js_code += f"      {full_name}PendingReceiver,\n"
                  js_code += "      handle);\n"
                  js_code += f"    this.$ = new {full_name}RemoteCallHandler(this.proxy);\n"
                  js_code += "  }\n\n"
                  
                  js_code += "  bindNewPipeAndPassReceiver() {\n"
                  js_code += "    return this.proxy.bindNewPipeAndPassReceiver();\n"
                  js_code += "  }\n\n"
                  
                  js_code += "  close() {\n"
                  js_code += "    this.proxy.close();\n"
                  js_code += "  }\n"
                  js_code += "};\n\n"
                  
                  # Generate RemoteCallHandler with methods
                  js_code += f"{full_name}RemoteCallHandler = class {{\n"
                  js_code += "  constructor(proxy) {\n"
                  js_code += "    this.proxy = proxy;\n"
                  js_code += "  }\n\n"
                  
                  for idx, method in enumerate(interface.get('methods', [])):
                      ordinal = method.get('ordinal')
                      if ordinal is None: ordinal = idx
                      
                      params_list = [p['name'] for p in method.get('params', []) if p and p.get('name')]
                      params_str = ', '.join(params_list)
                      method_name_camel = to_camel_case(method['name'])
                      
                      js_code += f"  {method_name_camel}({params_str}) {{\n"
                      js_code += f"    // Ordinal: {ordinal}\n"
                      js_code += "    return this.proxy.sendMessage(\n"
                      js_code += f"      {ordinal},  // ordinal\n"
                      js_code += f"      {full_name}_{method['name']}_ParamsSpec,\n"
                      if not method.get('is_one_way'):
                          js_code += f"      {full_name}_{method['name']}_ResponseParamsSpec,\n"
                      else:
                          js_code += "      null,\n"
                      js_code += f"      [{params_str}]);\n"
                      js_code += "  }\n\n"
                  
                  js_code += "};\n\n"
                  
                  # Generate static getRemote() factory function
                  js_code += f"{full_name}.getRemote = function() {{\n"
                  js_code += f"  let remote = new {full_name}Remote();\n"
                  js_code += "  let receiver = remote.bindNewPipeAndPassReceiver();\n"
                  js_code += f"  mojo.internal.interfaceSupport.bind(\n"
                  js_code += f"    receiver.handle,\n"
                  js_code += f"    '{interface_string}',\n"
                  js_code += "    'context');\n"
                  js_code += "  return remote.$;\n"
                  js_code += "};\n\n"
                  
                   # Legacy compatibility
                   js_code += f"{full_name}Ptr = {full_name}Remote;\n"
                   js_code += f"{full_name}Request = {full_name}PendingReceiver;\n\n"
               
              return js_code



          def main():
              bindings_dir = Path('bindings')
              
              with open('mojom_files.txt', 'r') as f:
                  files = [line.strip() for line in f if line.strip()]
              
              print(f"Processing {len(files)} files...")
              
              success_count = 0
              
              index_data = {
                  'generated_at': datetime.datetime.utcnow().isoformat() + 'Z',
                  'interfaces': [],
                  'files': []
              }
              
              # Pass 1: Parse all files and build Global Type Map
              all_parsed = []
              global_kind_map = {}
              
              for mojom_path in files:
                  if not os.path.isfile(mojom_path):
                      continue
                  
                  parsed = parse_mojom_file(mojom_path)
                  if parsed:
                      all_parsed.append({'path': mojom_path, 'data': parsed})
                      
                      # Populate Global Map
                      mod_prefix = f"{parsed['module']}." if parsed.get('module') else ""
                      for s in parsed.get('structs', []): global_kind_map[f"{mod_prefix}{s['name']}"] = 'struct'
                      for u in parsed.get('unions', []): global_kind_map[f"{mod_prefix}{u['name']}"] = 'union'
                      for e in parsed.get('enums', []): global_kind_map[f"{mod_prefix}{e['name']}"] = 'enum'
                      for i in parsed.get('interfaces', []): global_kind_map[f"{mod_prefix}{i['name']}"] = 'interface'
              
              print(f"Global Type Map detected {len(global_kind_map)} types.")

              # Pass 2: Generate Bindings
              for item in all_parsed:
                  mojom_path = item['path']
                  parsed = item['data']
                  
                  if parsed and (parsed.get('interfaces') or parsed.get('structs') or parsed.get('unions') or parsed.get('enums')):
                      rel_path = mojom_path.replace('chromium_src/', '')
                      out_filename = rel_path.replace('/', '_').replace('.mojom', '.mojom.js')
                      out_path = bindings_dir / out_filename
                      
                      js_code = generate_js_binding(parsed, global_kind_map)
                      if js_code:
                          with open(out_path, 'w') as f:
                              f.write(js_code)
                          success_count += 1
                          
                          for interface in parsed['interfaces']:
                              index_data['interfaces'].append({
                                  'name': interface['name'],
                                  'module': parsed['module'],
                                  'file': out_filename,
                                  'methods': [m['name'] for m in interface.get('methods', [])]
                              })
                          
                          index_data['files'].append({
                              'filename': out_filename,
                              'source': rel_path,
                              'module': parsed['module'],
                              'imports': parsed.get('imports', [])
                          })
              
              # Write index.json
              with open(bindings_dir / 'index.json', 'w') as f:
                  json.dump(index_data, f, indent=2)
              
              # Print summary
              print(f"\n=== Results ===")
              print(f"Generated bindings: {success_count} files")
              print(f"Total interfaces: {len(index_data['interfaces'])}")

          if __name__ == '__main__':
              main()
          SCRIPT
          
          # Run the script
          python generate_bindings.py
          


      - name: Generate index.js
        run: |
          cat > bindings/index.js << 'EOF'
          // MojoJS Bindings Index
          // Auto-generated - Do not edit manually

          (function(global) {
            'use strict';

            // Create trusted types policy for script URLs
            let trustedPolicy = null;
            if (typeof window.trustedTypes !== 'undefined') {
              try {
                trustedPolicy = window.trustedTypes.createPolicy('mojoBindings', {
                  createScriptURL: (input) => input
                });
              } catch (e) {
                console.warn('Could not create trusted types policy:', e);
              }
            }

            const MojoBindings = {
              _indexData: null,
              _loadedModules: {},

              async loadIndex() {
                if (this._indexData) return this._indexData;
                const response = await fetch('./bindings/index.json');
                this._indexData = await response.json();
                return this._indexData;
              },

              async getInterfaces() {
                const data = await this.loadIndex();
                return data.interfaces;
              },

              async searchInterfaces(query) {
                const interfaces = await this.getInterfaces();
                const q = query.toLowerCase();
                return interfaces.filter(i => 
                  i.name.toLowerCase().includes(q) || 
                  i.module.toLowerCase().includes(q)
                );
              },

              async loadBinding(filename) {
                if (this._loadedModules[filename]) {
                  return this._loadedModules[filename];
                }
                
                // Load index to resolve dependencies
                const data = await this.loadIndex();
                const fileEntry = data.files.find(f => f.filename === filename);
                
                if (fileEntry && fileEntry.imports && fileEntry.imports.length > 0) {
                  const loadPromises = fileEntry.imports.map(async (importPath) => {
                     // Find the file entry that matches this import source
                     const importEntry = data.files.find(f => f.source === importPath);
                     if (importEntry) {
                       await this.loadBinding(importEntry.filename);
                     }
                  });
                  await Promise.all(loadPromises);
                }

                return new Promise((resolve, reject) => {
                  this._loadedModules[filename] = true;

                  const script = document.createElement('script');
                  const scriptUrl = `./bindings/${filename}`;
                  
                  if (trustedPolicy) {
                    script.src = trustedPolicy.createScriptURL(scriptUrl);
                  } else {
                    script.src = scriptUrl;
                  }
                  
                  script.onload = () => {
                    resolve(true);
                  };
                  script.onerror = () => {
                    reject(new Error(`Failed to load binding: ${filename}`));
                  };
                  document.head.appendChild(script);
                });
              },

              getMetadata() {
                return this._indexData;
              }
            };

            global.MojoBindings = MojoBindings;
          })(typeof window !== 'undefined' ? window : this);
          EOF



      - name: Cleanup temporary files
        run: |
          # Remove all temporary files that should NOT be committed
          rm -rf chromium_src/
          rm -f mojom_files.txt
          echo "Cleaned up temporary files"

      - name: Commit only generated binding files
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Only add generated binding files - NOT core runtime files
          # Core files (bindings_lite.js, interface_support.js, etc.) should not be modified
          git add bindings/*.mojom.js
          git add bindings/index.js
          git add bindings/index.json
          
          # Show what will be committed
          echo "Files staged for commit:"
          git diff --staged --name-only
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            CHANGED_COUNT=$(git diff --staged --name-only | wc -l)
            git commit -m "Update Mojo JS bindings - $(date -u +%Y-%m-%d) [$CHANGED_COUNT files]"
            git push
          fi
