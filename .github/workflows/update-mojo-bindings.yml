name: Update Mojo JS Bindings

on:
  schedule:
    - cron: '0 0 * * 0'  # Weekly on Sunday at midnight UTC
  workflow_dispatch:  # Manual trigger
  push:
    branches: [main]
    paths:
      - '.github/workflows/update-mojo-bindings.yml'

permissions:
  contents: write

jobs:
  update-bindings:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Create working directories
        run: |
          mkdir -p chromium_src
          mkdir -p bindings

      - name: Sparse checkout .mojom files from Chromium
        run: |
          cd chromium_src
          git init
          git remote add origin https://chromium.googlesource.com/chromium/src.git
          git config core.sparseCheckout true
          
          # Use universal pattern to get ALL .mojom files regardless of location
          # Also get mojo/public for base types and dependencies
          cat > .git/info/sparse-checkout << 'EOF'
          mojo/public/
          **/*.mojom
          EOF
          
          git pull --depth=1 origin main || git pull --depth=1 origin master

      - name: List .mojom files
        run: |
          # Finds all .mojom files in chromium_src
          # We sort them to help with stability, though dependencies matter more
          find chromium_src -name "*.mojom" | sort > mojom_files.txt
          
          echo "Found $(wc -l < mojom_files.txt) .mojom files"
          head -10 mojom_files.txt

      - name: Generate Mojo JS bindings
        run: |
          echo "Generating Mojo JS bindings..."
          
          # Set up paths
          export PYTHONPATH="$PYTHONPATH:$(pwd)/chromium_src"
          
          # Run the external script
          python generate_bindings.py
              
              current_ns = module_parts[0]
              for part in module_parts[1:]:
                  js_code += f"{current_ns}.{part} = {current_ns}.{part} || {{}};\n"
                  current_ns += f".{part}"
              
              # Declare external namespaces from imports (dynamic)
              declared_roots = set()
              # Add current module root to avoid redeclaration or logic error
              declared_roots.add(module_parts[0])
              
              for imp in parsed.get('imports', []):
                  mod = None
                  # Try exact path match
                  if imp in file_to_module:
                      mod = file_to_module[imp]
                  else:
                      # Try suffix match
                      for k, v in file_to_module.items():
                          if k.endswith(imp):
                              mod = v
                              break
                  
                  if mod:
                      root = mod.split('.')[0]
                      if root not in declared_roots:
                          js_code += f"var {root} = {root} || {{}};\n"
                          declared_roots.add(root)
                  else:
                       # Fallback heuristic for standard libraries if not in file list
                       parts = imp.split('/')
                       roots = ['blink', 'ui', 'gfx', 'skia', 'url', 'content', 'ash', 'chromeos', 'components', 'services', 'network', 'media', 'webview']
                       for r in roots:
                           if r in parts and r not in declared_roots:
                               js_code += f"var {r} = {r} || {{}};\n"
                               declared_roots.add(r)
              
              js_code += "\n"
              
              # Pre-declare all Spec objects to handle circular dependencies
              for enum in parsed.get('enums', []):
                  js_code += f"{current_ns}.{enum['name']}Spec = {{ $: mojo.internal.Enum() }};\n"
              for union in parsed.get('unions', []):
                  js_code += f"{current_ns}.{union['name']}Spec = {{ $: {{}} }};\n"
              for struct in parsed.get('structs', []):
                  js_code += f"{current_ns}.{struct['name']}Spec = {{ $: {{}} }};\n"
              for interface in parsed.get('interfaces', []):
                  iface_name = interface['name']
                  js_code += f"{current_ns}.{iface_name} = {{}};\n"
                  js_code += f"{current_ns}.{iface_name}.$interfaceName = '{module}.{iface_name}';\n"
                  for method in interface.get('methods', []):
                      js_code += f"{current_ns}.{iface_name}_{method['name']}_ParamsSpec = {{ $: {{}} }};\n"
                      if not method.get('is_one_way'):
                          js_code += f"{current_ns}.{iface_name}_{method['name']}_ResponseParamsSpec = {{ $: {{}} }};\n"

              # Generate constants
              for const in parsed.get('constants', []):
                  js_code += f"\n{current_ns}.{const['name']} = {const['value']};\n"

              # Generate enums
              for enum in parsed.get('enums', []):
                  js_code += f"\n// Enum: {enum['name']}\n"
                  js_code += f"{current_ns}.{enum['name']} = {{\n"
                  last_val = -1
                  for entry in enum['values']:
                      v_name = entry['name']
                      v_val = entry['value']
                      if v_val is not None:
                          try:
                              last_val = int(v_val, 0)
                          except:
                              pass # Could be another constant reference, but we prefer literal
                      else:
                          last_val += 1
                      js_code += f"  {v_name}: {last_val},\n"
                  js_code += "};\n"
                  # EnumSpec already pre-declared



              # Generate unions
              for union in parsed.get('unions', []):
                  union_name = union['name']
                  full_name = f"{current_ns}.{union_name}"
                  
                  js_code += f"\n// Union: {union_name}\n"
                  js_code += f"mojo.internal.Union(\n"
                  js_code += f"    {full_name}Spec, '{module}.{union_name}', {{\n"
                  
                  for i, field in enumerate(union['fields']):
                      f_type = resolve_mojo_type(field['type'])
                      f_ordinal = field.get('ordinal', i) # Fallback to index if no ordinal
                      if f_ordinal is None: f_ordinal = i
                      
                      f_nullable = 'true' if field.get('optional') or '?' in field.get('type', '') else 'false'
                      js_code += f"      '{field['name']}': {{\n"
                      js_code += f"        'ordinal': {f_ordinal},\n"
                      js_code += f"        'type': {f_type},\n"
                      js_code += f"        'nullable': {f_nullable},\n"
                      js_code += "      },\n"
                      
                  js_code += "    });\n"

              # Generate structs
              for struct in parsed.get('structs', []):
                  struct_name = struct['name']
                  full_name = f"{current_ns}.{struct_name}"
                  fields_code, packed_size, versions_code = get_struct_layout(struct.get('fields', []))
                  
                  js_code += f"\n// Struct: {struct_name}\n"
                  js_code += f"mojo.internal.Struct(\n"
                  js_code += f"    {full_name}Spec, '{module}.{struct_name}', [\n"
                  for field in fields_code:
                      js_code += f"      mojo.internal.StructField({field}),\n"
                  js_code += f"    ],\n"
                  js_code += f"    {versions_code});\n"
              
              # Generate interface classes with proper getRemote() method
              for interface in parsed.get('interfaces', []):
                  iface_name = interface['name']
                  full_name = f"{current_ns}.{iface_name}"
                  interface_string = f"{module}.{iface_name}"
                  
                  # Interface object already pre-declared bit metadata added
                  js_code += f"\n// Interface: {iface_name}\n"
                  
                  # Generate Method Structs (Params & Responses)
                  for method in interface.get('methods', []):
                      method_name = method['name']
                      
                      # Request Params
                      params = method.get('params', [])
                      param_struct_name = f"{iface_name}_{method_name}_Params"
                      p_fields, p_size, p_versions = get_struct_layout(params)
                      
                      js_code += f"mojo.internal.Struct(\n"
                      js_code += f"    {current_ns}.{param_struct_name}Spec, '{module}.{param_struct_name}', [\n"
                      for field in p_fields:
                          js_code += f"      mojo.internal.StructField({field}),\n"
                      js_code += f"    ],\n"
                      js_code += f"    {p_versions});\n\n"

                      # Response Params
                      if not method.get('is_one_way'):
                          resp_params = method.get('returns', [])
                          resp_struct_name = f"{iface_name}_{method_name}_ResponseParams"
                          r_fields, r_size, r_versions = get_struct_layout(resp_params)
                          
                          js_code += f"mojo.internal.Struct(\n"
                          js_code += f"    {current_ns}.{resp_struct_name}Spec, '{module}.{resp_struct_name}', [\n"
                          for field in r_fields:
                              js_code += f"      mojo.internal.StructField({field}),\n"
                          js_code += f"    ],\n"
                          js_code += f"    {r_versions});\n\n"

                  # Generate PendingReceiver class first (needed by Remote)
                  
                  # Generate PendingReceiver class first (needed by Remote)
                  js_code += f"{full_name}PendingReceiver = class {{\n"
                  js_code += "  constructor(handle) {\n"
                  js_code += "    this.handle = handle;\n"
                  js_code += "  }\n"
                  js_code += "};\n\n"
                  
                  # Generate Remote class with getRemote() static method
                  js_code += f"{full_name}Remote = class {{\n"
                  js_code += f"  static get $interfaceName() {{\n"
                  js_code += f"    return '{interface_string}';\n"
                  js_code += "  }\n\n"
                  
                  js_code += "  constructor(handle = undefined) {\n"
                  js_code += f"    this.proxy = new mojo.internal.interfaceSupport.InterfaceRemoteBase(\n"
                  js_code += f"      {full_name}PendingReceiver,\n"
                  js_code += "      handle);\n"
                  js_code += f"    this.$ = new {full_name}RemoteCallHandler(this.proxy);\n"
                  js_code += "  }\n\n"
                  
                  js_code += "  bindNewPipeAndPassReceiver() {\n"
                  js_code += "    return this.proxy.bindNewPipeAndPassReceiver();\n"
                  js_code += "  }\n\n"
                  
                  js_code += "  close() {\n"
                  js_code += "    this.proxy.close();\n"
                  js_code += "  }\n"

                  for method in interface.get('methods', []):
                      method_name_camel = to_camel_case(method['name'])
                      params_list = [p['name'] for p in method.get('params', []) if p and p.get('name')]
                      params_str = ', '.join(params_list)
                      js_code += f"  {method_name_camel}({params_str}) {{\n"
                      js_code += f"    return this.$.{method_name_camel}({params_str});\n"
                      js_code += "  }\n"

                  js_code += "};\n\n"
                  
                  # Generate RemoteCallHandler with methods
                  js_code += f"{full_name}RemoteCallHandler = class {{\n"
                  js_code += "  constructor(proxy) {\n"
                  js_code += "    this.proxy = proxy;\n"
                  js_code += f"    this.ordinals = window.mojoScrambler.getOrdinals('{iface_name}', [\n"
                  for method in interface.get('methods', []):
                      ord_val = method.get('ordinal')
                      js_code += f"      {{ explicit: {'null' if ord_val is None else ord_val} }},\n"
                  js_code += "    ]);\n"
                  js_code += "  }\n\n"
                  
                  for idx, method in enumerate(interface.get('methods', [])):
                      params_list = [p['name'] for p in method.get('params', []) if p and p.get('name')]
                      params_str = ', '.join(params_list)
                      method_name_camel = to_camel_case(method['name'])
                      
                      js_code += f"  {method_name_camel}({params_str}) {{\n"
                      js_code += "    return this.proxy.sendMessage(\n"
                      js_code += f"      this.ordinals[{idx}],  // ordinal\n"
                      js_code += f"      {full_name}_{method['name']}_ParamsSpec,\n"
                      if not method.get('is_one_way'):
                          js_code += f"      {full_name}_{method['name']}_ResponseParamsSpec,\n"
                      else:
                          js_code += "      null,\n"
                      js_code += f"      [{params_str}],\n"
                      js_code += "      false);\n"
                      js_code += "  }\n\n"
                  
                  js_code += "};\n\n"
                  
                  # Generate static getRemote() factory function
                  js_code += f"{full_name}.getRemote = function() {{\n"
                  js_code += f"  let remote = new {full_name}Remote();\n"
                  js_code += "  let receiver = remote.bindNewPipeAndPassReceiver();\n"
                  js_code += f"  mojo.internal.interfaceSupport.bind(\n"
                  js_code += f"    receiver.handle,\n"
                  js_code += f"    '{interface_string}',\n"
                  js_code += "    'context');\n"
                  js_code += "  return remote.$;\n"
                  js_code += "};\n\n"
                  
                  # Generate Receiver class
                  js_code += f"{full_name}Receiver = class {{\n"
                  js_code += "  constructor(impl) {\n"
                  js_code += "    this.impl = impl;\n"
                  js_code += "    this.endpoint = null;\n"
                  js_code += "    this.ordinalMap = new Map();\n"
                  js_code += f"    const ordinals = window.mojoScrambler.getOrdinals('{iface_name}', [\n"
                  for method in interface.get('methods', []):
                      ord_val = method.get('ordinal')
                      js_code += f"      {{ explicit: {'null' if ord_val is None else ord_val} }},\n"
                  js_code += "    ]);\n"
                  js_code += "    ordinals.forEach((ord, idx) => {\n"
                  js_code += "      this.ordinalMap.set(ord, idx); // Scrambled/Explicit\n"
                  js_code += "      this.ordinalMap.set(idx, idx); // Sequential Fallback (Non-scrambled builds)\n"
                  js_code += "    });\n"
                  js_code += "    console.log('[GeneratedReceiver] Constructed for ' + this.impl);\n"
                  js_code += "  }\n"
                  js_code += "  mapOrdinal(hash, id) { this.ordinalMap.set(hash, id); }\n"
                  js_code += "  bind(handle) {\n"
                  js_code += "    console.log('[GeneratedReceiver] Binding handle...');\n"
                  js_code += "    this.router_ = new mojo.internal.interfaceSupport.Router(handle, false);\n"
                  js_code += "    this.endpoint = new mojo.internal.interfaceSupport.Endpoint(this.router_);\n"
                  js_code += "    this.endpoint.start({ onMessageReceived: (...args) => {\n"
                  js_code += "      try {\n"
                  js_code += "      console.log('[GeneratedReceiver] FRESH LOADER: Args received', args);\n"
                  js_code += "      let message = args[0];\n"
                  js_code += "      // Handle decomposed arguments from internal runtime (endpoint, header, buffer, handles)\n"
                  js_code += "      if (args.length > 1 && args[0] instanceof mojo.internal.interfaceSupport.Endpoint) {\n"
                  js_code += "        // Create a view of ONLY the payload (skipping the header)\n"
                  js_code += "        let payload = args[2];\n"
                  js_code += "        const headerSize = args[1].headerSize;\n"
                  js_code += "        if (payload instanceof ArrayBuffer) {\n"
                  js_code += "           payload = new DataView(payload, headerSize);\n"
                  js_code += "        }\n"
                  js_code += "        message = {\n"
                  js_code += "          header: args[1],\n"
                  js_code += "          payload: payload,\n"
                  js_code += "          handles: args[3] || []\n"
                  js_code += "        };\n"
                  js_code += "      }\n"
                  js_code += "      const header = message && message.header;\n"
                  js_code += "      if (!header) return;\n"
                  js_code += "      let dispatchId = this.ordinalMap.get(header.ordinal);\n"
                  
                  # HEURISTIC DISCOVERY
                  js_code += "      if (dispatchId === undefined) {\n"
                  js_code += "        // Unknown ordinal (hashed). Attempt to discover mapping by trial-decoding.\n"
                  js_code += "        console.log('[GeneratedReceiver] Unknown ordinal ' + header.ordinal + '. Attempting heuristic discovery...');\n"
                  js_code += "        // Decoder uses payload view starting at 0\n"
                  js_code += "        const decoder = new mojo.internal.Decoder(message.payload, message.handles);\n"
                  js_code += "        \n"
                  
                  # Generate trial logic for each method
                  for idx, method in enumerate(interface.get('methods', [])):
                       method_name = method['name']
                       param_struct_name = f"{iface_name}_{method_name}_Params"
                       
                       js_code += f"        // Try Method {idx}: {method_name}\n"
                       js_code += "        if (dispatchId === undefined) {\n"
                       js_code += "           try {\n"
                       # DECODE INLINE (Payload IS the struct, not a pointer to it)
                       js_code += f"             decoder.decodeStructInline({current_ns}.{param_struct_name}Spec);\n"
                       js_code += f"             console.log('[GeneratedReceiver] Discovery SUCCESS: ' + header.ordinal + ' -> {method_name} ({idx})');\n"
                       js_code += f"             this.mapOrdinal(header.ordinal, {idx});\n"
                       js_code += f"             dispatchId = {idx};\n"
                       js_code += "           } catch (e) {\n"
                       js_code += f"             console.warn('[GeneratedReceiver] Discovery trial {idx} failed:', e);\n"
                       js_code += "           }\n"
                       js_code += "        }\n"

                  js_code += "        if (dispatchId === undefined) {\n"
                  js_code += "             console.warn('[GeneratedReceiver] Failed to discover ordinal ' + header.ordinal);\n"
                  js_code += "             return;\n"
                  js_code += "        }\n"
                  js_code += "      }\n" # End discovery block
                  
                  js_code += "      console.log('[GeneratedReceiver] Dispatching ordinal:', header.ordinal, 'as ID:', dispatchId);\n"
                  js_code += "      switch (dispatchId) {\n"
                  
                  for idx, method in enumerate(interface.get('methods', [])):
                      # Use Index as the dispatch ID for internal switch logic (since discovery maps to idx)
                      ordinal = idx 
                      
                      method_name = method['name']
                      method_name_camel = to_camel_case(method_name)
                      
                      js_code += f"        case {idx}: {{\n"
                      
                      # Decode params MANUALLY
                      param_struct_name = f"{iface_name}_{method_name}_Params"
                      # js_code += f"          const params = {current_ns}.{param_struct_name}Spec.$.decode(message.payload);\n"
                      # MANUAL DECODE with OFFSET
                      js_code += f"          const decoder = new mojo.internal.Decoder(message.payload, message.handles);\n"
                      # Use decodeStructInline because payload IS the struct, not a pointer
                      js_code += f"          const params = decoder.decodeStructInline({current_ns}.{param_struct_name}Spec.$.structSpec);\n"
                      
                      # Call implementation
                      param_names = [p['name'] for p in method.get('params', []) if p and p.get('name')]
                      args_js = ", ".join([f"params.{name}" for name in param_names])
                      
                      js_code += f"          console.log('[GeneratedReceiver] Calling impl.{method_name_camel}');\n"
                      js_code += f"          const result = this.impl.{method_name_camel}({args_js});\n"
                      
                      # Handle response
                      if not method.get('is_one_way'):
                          resp_struct_name = f"{iface_name}_{method_name}_ResponseParams"
                          js_code += f"          if (header.expectsResponse) {{\n"
                          js_code += f"            Promise.resolve(result).then(response => {{\n"
                          js_code += f"              const responder = mojo.internal.interfaceSupport.createResponder(this.endpoint, header.requestId, {current_ns}.{resp_struct_name}Spec);\n"
                          js_code += "               responder(response);\n"
                          js_code += "            });\n"
                          js_code += "          }\n"
                          
                      js_code += "          break;\n"
                      js_code += "        }\n"
                  
                  js_code += "      }\n" # End switch
                  js_code += "      } catch (err) {\n"
                  js_code += "        console.error('[GeneratedReceiver] Error processing message:', err);\n"
                  js_code += "      }\n"
                  js_code += "    }});\n" # End start
                  js_code += "  }\n"
                  js_code += "};\n\n"
                  
                  # Legacy/Lite Alias
                  js_code += f"{current_ns}.{iface_name}Receiver = {full_name}Receiver;\n\n"
                  
                  # Legacy compatibility
                  js_code += f"{full_name}Ptr = {full_name}Remote;\n"
                  js_code += f"{full_name}Request = {full_name}PendingReceiver;\n\n"
               
              return js_code



          def main():
              bindings_dir = Path('bindings')
              
              with open('mojom_files.txt', 'r') as f:
                  files = [line.strip() for line in f if line.strip()]
              
              print(f"Processing {len(files)} files...")
              
              success_count = 0
              
              index_data = {
                  'generated_at': datetime.datetime.utcnow().isoformat() + 'Z',
                  'interfaces': [],
                  'files': []
              }
              
              # Pass 1: Parse all files and build Global Type Map
              all_parsed = []
              global_kind_map = {}
              file_to_module = {} # Map file path -> module name
              
              for mojom_path in files:
                  if not os.path.isfile(mojom_path):
                      continue
                  
                  parsed = parse_mojom(mojom_path)
                  if parsed:
                      all_parsed.append({'path': mojom_path, 'data': parsed})
                      
                      # Map file to module for import resolution
                      if parsed.get('module'):
                          real_path = str(Path(mojom_path)) # normalize
                          file_to_module[real_path] = parsed['module']
                          # Also map the raw path as found in list
                          file_to_module[mojom_path] = parsed['module']
                      
                      # Populate Global Map
                      mod_prefix = f"{parsed['module']}." if parsed.get('module') else ""
                      for s in parsed.get('structs', []): global_kind_map[f"{mod_prefix}{s['name']}"] = 'struct'
                      for u in parsed.get('unions', []): global_kind_map[f"{mod_prefix}{u['name']}"] = 'union'
                      for e in parsed.get('enums', []): global_kind_map[f"{mod_prefix}{e['name']}"] = 'enum'
                      for i in parsed.get('interfaces', []): global_kind_map[f"{mod_prefix}{i['name']}"] = 'interface'
              
              print(f"Global Type Map detected {len(global_kind_map)} types.")

              # Pass 2: Generate Bindings
              for item in all_parsed:
                  mojom_path = item['path']
                  parsed = item['data']
                  
                  if parsed and (parsed.get('interfaces') or parsed.get('structs') or parsed.get('unions') or parsed.get('enums')):
                      rel_path = mojom_path.replace('chromium_src/', '')
                      out_filename = rel_path.replace('/', '_').replace('.mojom', '.mojom.js')
                      out_path = bindings_dir / out_filename
                      
                      js_code = generate_js_binding(parsed, global_kind_map, file_to_module)
                      if js_code:
                          with open(out_path, 'w') as f:
                              f.write(js_code)
                          success_count += 1
                          
                          for interface in parsed['interfaces']:
                              index_data['interfaces'].append({
                                  'name': interface['name'],
                                  'module': parsed['module'],
                                  'file': out_filename,
                                  'methods': [m['name'] for m in interface.get('methods', [])]
                              })
                          
                          index_data['files'].append({
                              'filename': out_filename,
                              'source': rel_path,
                              'module': parsed['module'],
                              'imports': parsed.get('imports', [])
                          })
              
              # Write index.json
              with open(bindings_dir / 'index.json', 'w') as f:
                  json.dump(index_data, f, indent=2)
              
              # Print summary
              print(f"\n=== Results ===")
              print(f"Generated bindings: {success_count} files")
              print(f"Total interfaces: {len(index_data['interfaces'])}")

          if __name__ == '__main__':
              main()
          SCRIPT
          
          # Run the script
          python generate_bindings.py

      - name: Cleanup temporary files
        run: |
          # Remove all temporary files that should NOT be committed
          rm -rf chromium_src/
          rm -f mojom_files.txt
          echo "Cleaned up temporary files"

      - name: Commit only generated binding files
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Only add generated binding files - NOT core runtime files
          # Core files (bindings_lite.js, interface_support.js, etc.) should not be modified
          git add bindings/*.mojom.js
          git add bindings/index.js
          git add bindings/index.json
          
          # Show what will be committed
          echo "Files staged for commit:"
          git diff --staged --name-only
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            CHANGED_COUNT=$(git diff --staged --name-only | wc -l)
            git commit -m "Update Mojo JS bindings - $(date -u +%Y-%m-%d) [$CHANGED_COUNT files]"
            git push
          fi
